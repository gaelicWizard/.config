#!/bin/bash -c 'this file is not executable. source it.'

import trash || return -1
    # Import my trash package for
        # del

export AP_PADDING="DEFAULT_PAD=8192:MIN_PAD=0:MAX_PAD=8192"
export PIC_OPTIONS="removeTempPix:AddBothPix=true"
    # Set up a bunch of defaults for AtomicParsley(1) so that finishing up
    #  the tagging process is later is less painful.

##
# tagging globals
theListOfAllTheTrackTags=( title artist description longDescription genre year copyright advisory stik contentRating TVEpisode TVEpisodeNum composer comment )
theListOfAllTheTrackiTunMOVITags=( studio cast codirectors coexecutiveproducers coproducers directors producers screenwriters executiveproducers supervisingproducers assistantproducers associateproducers coordinatingproducers consultingproducers )
theListOfAdditionalTrackMetadata=( ratingAdvisory audioList angleList chapterList subtitleList feature usesShow videoTitleSet )
theListOfSpecialTrackFlagsForHandBrake=( crop grayscale )
theListOfAllTheDiscTags=( disk )
theListOfAdditionalDiscMetadata=( maxtrack trackList UDFVolumeName diskid )
theListOfAllTheAlbumTags=( TVShowName TVSeasonNum albumArtist album year TVNetwork artwork )
theListOfAdditionalAlbumMetadata=( UPC ISBN ASIN label maxdisk )
# end tagging globals
##

function ripDebug ()
{
    export DEBUG_DISABLE_HANDBRAKE_INVOCATION=DEBUG_DISABLE_HANDBRAKE_INVOCATION
    export DEBUG_DISABLE_ATOMICPARSLEY_INVOCATION=DEBUG_DISABLE_ATOMICPARSLEY_INVOCATION
    export DO_NOT_TWEET_RIPS=DO_NOT_TWEET_RIPS
    export DEBUG_DISABLE_TAR_INVOCATION=DEBUG_DISABLE_TAR_INVOCATION
    export HANDBRAKE_DEBUG_LEVEL=1
    
    echo "$DEBUG_DISABLE_HANDBRAKE_INVOCATION; $DEBUG_DISABLE_ATOMICPARSLEY_INVOCATION; $DO_NOT_TWEET_RIPS; $DEBUG_DISABLE_TAR_INVOCATION; $HANDBRAKE_DEBUG_LEVEL" 1>&2
}

function ripAlbum ()
# Loops ripDisc for each "$@"
{
    local movie

    for movie in "$@"
    do
        DEBUG_DISABLE_TAR_INVOCATION=DEBUG_DISABLE_TAR_INVOCATION \
        ripDisc "$movie" || return
    done

    #ripGrowl "${ALBUM}."
}

function sanitiseFilePath ()
# This function should take a string which may not be a valid filesystem path and should produce a valid filesystem path.
#TODO:FIXME: Implement
#TODO:FIXME: Move to general package. Shouldn't be in rip package.
{
    return -1
}

function ripDisc ()
# Invokes rip() on $1 specifying which titles to rip from atomicMetadata, autotagTrack() on each track, then tar(1)s and moves dvdmedia to trash.
# Uses rip()
# Uses ripGrowl()
# Uses autotagTrack()
# Uses del #trash
# Uses defaultsReadAtomicMetadata()
# Uses defaultsReadAtomicMetadatas()
{
    local dvdmedia="$1" \
          track

    local ALBUM="$(defaultsReadAtomicMetadata "$dvdmedia" Album album)" \
          DISK="$(defaultsReadAtomicMetadata "$dvdmedia" Disc disk)" \
          VOLUME="$(defaultsReadAtomicMetadata "$dvdmedia" Disc UDFVolumeName)" \
          MAXDISK="$(defaultsReadAtomicMetadata "$dvdmedia" Album maxdisk)" \
          filepath FILE trackName

    ripValidate "$dvdmedia" || return

    if [ "$MAXDISK" -eq 1 ]
    # No need for per-disc subfolders if there's only one disc.
    then
        filepath="./${ALBUM}"
    else
        filepath="./${ALBUM}/${ALBUM}: Disc ${DISK}"
    fi
    mkdir -p "./${filepath}"
        # Since $ALBUM is unsanitised, prefix it with "./", since we'd rather error than overwrite something elsewhere.

    for track in $(defaultsReadAtomicMetadata "$dvdmedia" Disc trackList)
    do
        trackName="$(defaultsReadAtomicMetadatas "$dvdmedia" "$track" title)"
        #FILE="${filepath}/${VOLUME}-${track}.m4v" # Imitate HandBrake file naming.
        FILE="${filepath}/${DISK}-${track} ${trackName}.m4v" # Imitate iTunes file naming.

        time rip "$dvdmedia" "$track" "$FILE" \
        && \
        autotagTrack "$dvdmedia" "$track" "$FILE" || return # short-circuit if something fails
    done

    ripGrowl "${ALBUM}: Disc ${DISK}" "$VOLUME"

    test -z "${DEBUG_DISABLE_TAR_INVOCATION:-}" && \
        { #TODO:FIXME: Move this to ripAlbum(). Make sure to integrate tarDVDsTogether.sh.
            tar cvf "./${filepath}/$(basename "$dvdmedia" .dvdmedia).tar" -C "$(dirname "$dvdmedia")" "$(basename "$dvdmedia")" || return
            del "$dvdmedia" || return
        } || test -n "${DEBUG_DISABLE_TAR_INVOCATION:-}" # Workaround: we don't want to "fail" (return non-zero) if we are _deliberately_ skipping tar(1) invocation.
}

function defaultsReadAtomicMetadatas ()
# Uses defaultsReadAtomicMetadata() to repeatedly read various atomicMetadataPlists in dvdmedia $1, track $2, until a value is found for key $3.
{
    local dvdmedia="$1"; shift
    local track="$1"; shift
    
    # The order of calls is important here. 
    # Track should override Show, which should override Disc, which should override Album. 
    # Without overrides, they should fall-through in that order.

    defaultsReadAtomicMetadata "$dvdmedia" Track "$track" "$@" && return # return on success
        # since $3 is only read by defaultsReadAtomicMetadata() when $2 is Track, we have to special-case it.

    if [ x"$(defaultsReadAtomicMetadata "$dvdmedia" Track "$track" usesShow)" == x"1" ]
    # Show is special-cased because bonus material in an album might not share the same show metadata as the actual features.
    then
        defaultsReadAtomicMetadata "$dvdmedia" Show "$@" && return # return on success
    fi

    local metadataType
    for metadataType in Disc Album
    do
        defaultsReadAtomicMetadata "$dvdmedia" "$metadataType" "$@" && return # return on success
    done
}

function defaultsReadAtomicMetadata ()
# Generates a full path (using $1) (minus .plist extension) to the given type of metadata ($2 and maybe $3), and uses defaults(1) to read $@ from it.
# There is code duplication with ripInit().
{
    local dvdmedia="$(realpath "$1")" || return -1
        # This requires a working realpath.
    shift # drop $dvdmedia from "$@"
    local whichAtomicMetadata="$1"; shift
    if [ x"$whichAtomicMetadata" == x"Track" ]
    then
        local whichAtomicMetadataTrack="${1:-}"; shift
    fi

    local atomicMetadataPlist="$dvdmedia/atomicMetadata${whichAtomicMetadata}${whichAtomicMetadataTrack:+-}${whichAtomicMetadataTrack:-}"

    defaults read "$atomicMetadataPlist" "$@" 2>/dev/null
        # Ignore "does not exist" messages.
}

function ripSanity () 
#TODO:FIXME: Merge with ripValidate?
# Check that rip() has sufficient information to operate.
# Uses defaultsReadAtomicMetadatas()
# Uses ripUsage()
{
    if ! test -d "${1}/VIDEO_TS"
    then
        echo "rip(): The first argument must be the full path to a DVDMedia bundle." 1>&2
        echo "       See ripInit()." 1>&2
        ripUsage
        return -1
    fi

    if ! defaultsReadAtomicMetadatas "$1" "$2" audioList >/dev/null
    # Assume that if no audioList can be found for track $2, then that track is not valid (or the atomicMetadata is incomplete).
    then
        echo "rip(): The list of audio tracks must be specified in atomicMetadata." 1>&2
        ripUsage
        return -2
    fi

    #TODO:FIXME: Sanity check for file name.
}

function ripFail () 
{
    RET="${?:-0}" #Â Preserve the return value.

    if [ x"$1" == x"audioList" ] || [ x"$1" == x"subtitleList" ] || [ x"$1" == x"angleList" ] || [ x"$1" == x"chapterList" ] || [ x"$1" == x"UDFVolumeName" ]
    then
        echo "rip(): Unable to read '$1' from atomicMetadata." 1>&2
        echo "       See initDVDMedia()." 1>&2
    else if [ x"$1" == x"ripParseAudioNames" ] || [ x"$1" == x"ripParseAudioTracks" ]
    then
        echo "rip(): Unable to parse '${2}List' (from atomicMetadata)." 1>&2
    else if [ x"$1" == x"HandBrakeCLI" ]
    then
        echo "rip(): HandBrake has failed to complete successfully." 1>&2
    else if [ x"$1" == x"HandBrakeCLI" ]
    then
        echo "rip(): HandBrake has failed to complete successfully." 1>&2
    fi
    fi
    fi
    fi
    
    if [ x"$1" == x"angleList" ] || [ x"$2" == x"angle" ]
    # Simple hack to prevent fatal exit when angleList is unspecified.
    #TODO:FIXME: Implement angleList
    #TODO:FIXME: Figure out how to be non-fatal.
    then
        RET=0
    fi

    ripUsage
    return "$RET";
}

function ripParseAudioNames ()
# Code duplication with ripParseAudioTracks().
{
    if [ x"$1" == x"" ] || [ x"$1" == x"_TAG_audioList_PLACEHOLDER_" ]
    then
        return -1
    fi

    local AUDIO_LIST="$1" \
          audio_track \
          IFS="," # Overriding IFS is ugly, bug efficient. Local'd so that it doesn't damage other stuff.
    for audio_track in $AUDIO_LIST
    do
        echo -n "${audio_track#*:},"
            # What audio tracks to encode
            # TODO: FIXME: Untested
    done
}

function ripParseAudioTracks () 
# Code duplication with ripParseAudioNames().
{
    if [ x"$1" == x"" ] || [ x"$1" == x"_TAG_audioList_PLACEHOLDER_" ]
    then
        return -1
    fi

    local AUDIO_LIST="$1" \
          audio_track \
          IFS="," # Overriding IFS is ugly, bug efficient. Local'd so that it doesn't damage other stuff.
    for audio_track in $AUDIO_LIST
    do
        echo -n "${audio_track%:*},"
            # What audio tracks to encode
            # TODO: FIXME: Untested
    done
}

function ripUsage () 
{
    echo "Usage: rip /path/to/DVD_VIDEO.dvdmedia 2 /path/to/file.m4v" 1>&2
}

function rip ()
# rip() /path/to/VIDEO_TS/.. 7 /path/to/file.m4v
# Uses defaultsReadAtomicMetadatas()
# Uses ripSanity()
# Uses ripFail()
# Uses ripParseAudioNames() #audio #subtitles #angles
# Uses ripParseAudioTracks()
# Uses addRipOptions()
# Uses SPECIAL_RIP_OPTIONS[]
{
    local dvdmedia="$1" # /path/to/VIDEO_TS's parent
    local whichTrack="$2" # integer, the track number/title number to encode
    local FILE="$3" # the file to save the encoded movie to.
    local SPECIAL_RIP_OPTIONS=( "${SPECIAL_RIP_OPTIONS[@]}" ) atomicRipOption ripOptionArg
         # Localise! #Untested

    ripSanity "$dvdmedia" "$whichTrack" "$chapterList" "$FILE" || return


    local DVDNAME="$(defaultsReadAtomicMetadatas "$dvdmedia" "$whichTrack" UDFVolumeName)" || ripFail "UDFVolumeName" || return
        # Use $DVDNAME as the base name for the log file.

    local chapterList="$(defaultsReadAtomicMetadatas "$dvdmedia" "$whichTrack" chapterList)" || ripFail "chapterList" || return
    local chapterTracks="${chapterList#*:}" # everything after the first colon
    local chapterName="${chapterList%%:*}" # everything before the first colon
        # There should only be one colon. 
        # $chapterName is not the name of the _one_ chapter to be encoded, but the name of the _set_ of chapters to be encoded.

    local audioList="$(defaultsReadAtomicMetadatas "$dvdmedia" "$whichTrack" audioList)" || ripFail "audioList" || return
    local audioNames="$(ripParseAudioNames "$audioList")" || ripFail "ripParseAudioNames" "audio" || return
    local audioTracks="$(ripParseAudioTracks "$audioList")" || ripFail "ripParseAudioTracks" "audio" || return
    local audioEncoders="$(IFS=,; for i in $audioTracks; do echo -n ca_aac,; done)"

    local subtitleList="$(defaultsReadAtomicMetadatas "$dvdmedia" "$whichTrack" subtitleList)" || ripFail "subtitleList" || return
    local subtitleNames="$(ripParseAudioNames "$subtitleList")" || ripFail "ripParseAudioNames" "subtitle" || return
        # Unused, due to a lack of support in HandBrake.
    local subtitleTracks="$(ripParseAudioTracks "$subtitleList")" || ripFail "ripParseAudioTracks" "subtitle" || return

    local angleList="$(defaultsReadAtomicMetadatas "$dvdmedia" "$whichTrack" angleList)" #|| ripFail "angleList" || return # angleList is not required
    local angleNames="$(ripParseAudioNames "$angleList")" || ripFail "ripParseAudioNames" "angle" || return
        # Unused.
    local angleTracks="$(ripParseAudioTracks "$angleList")" || ripFail "ripParseAudioTracks" "angle" || return
        # If only one angle is specified, then all is well. However, HandBrake cannot encode multiple angles simultaneously, so this option is presently worthless.
        #TODO:FIXME: Implement.
        # Most likely, the entire rip() will need to be looped in order to accomplish this.

    local videoTitleSet="$(defaultsReadAtomicMetadatas "$dvdmedia" "$whichTrack" videoTitleSet)" #|| ripFail "videoTitleSet" || return
        # This is intended to allow atomicMetadata to override the track/title number in order to allow ripBleach() et al to treat various sets of sub-chapters as distinct titles. 
            # For whatever reason, Anime titles (such as Bleach or Armitage III (OVA)) squeeze separate episodes together into a single title/track, thereby requiring special parsing/processing in order to split them.

    for atomicRipOption in "${theListOfSpecialTrackFlagsForHandBrake[@]}"
    do
        ripOptionArg="$(defaultsReadAtomicMetadatas "$dvdmedia" "$whichTrack" "$atomicRipOption")" && addRipOptions --"$atomicRipOption" "$ripOptionArg"
    done

    local handbrakePreset="$(defaults read net.gaelicWizard.rip preset 2>/dev/null)"
        # Allow override of preset

#Do it
    local RIPLOG=~/Library/Logs/net.gaelicWizard.rip/"$DVDNAME".log
    local RET=0
    test -z "${DEBUG_DISABLE_HANDBRAKE_INVOCATION:-}" && (
        test -e "$FILE" && del "$FILE"; \
        set -x; export LANG=C \
    exec HandBrakeCLI -v"${HANDBRAKE_DEBUG_LEVEL:-0}" \
        --preset "${handbrakePreset:=Universal}" \
        --input "$dvdmedia" \
        --title "${videoTitleSet:-${whichTrack:-FAIL}}" \
        "${chapterTracks:+--chapters}" "${chapterTracks:-}" \
        "${angleTracks:+--angle}" "${angleTracks:-}" \
        "${subtitleTracks:+--subtitle}" "${subtitleTracks:-}" \
        --previews 30 \
        --output "$FILE" \
        --markers="${dvdmedia}/chapters-${whichTrack}.txt" \
        --ipod-atom \
        --detelecine \
        --vfr \
        --audio "$audioTracks" \
        --aencoder "$audioEncoders" \
        "${audioNames:+--aname}" "${audioNames:-}" \
        "${SPECIAL_RIP_OPTIONS[@]}" \
    2>> "$RIPLOG" ) || ripFail "HandBrakeCLI" || return
        # Universal preset to activate sensible defaults.
        # Only encode selected chapters, if specified.
        # Encode the selected angle, if specified.
        # Pass-thru the selected subtitles, if specified. (Does _not_ burn-in, as of HandBrake 0.9.4+.)
        # Generate 30 previews, b/c I hope it will improve autocropping.
            # The number of previews generated is related to the accuracy of the autocropper, but seemingly only two previews are used.
        # Import chapter titles from CSV file, if available.
        # iPod atom, so that 5.5G iPods will accept the media.
        # Detelecine, always. Unclear why HandBrake doesn't just do this.
            # HandBrake documentation for the framerate setting implies that HandBrake does, in fact, detelecine by default. It lies.
        # Variable Frame Rate is the default, but didn't used to be.
            # This option disappeared _completely_ during 0.9.3
        # Enable selected audio tracks.
        # Encode them all to AAC, accepting default Dolby Pro Logic 2 encoding.
            # AAC is the default, so this line might be entirely unneeded.
            # However, the Universal preset duplicates track 1 to track 2 as pass-thru "AC-3", so it might be needed to _return_ to defaults. TODO: Untested, actually.
        # Name the selected audio tracks, e.g. "Director's Commentary".
        # Add any special out-of-band flags to HandBrake, such as "--crop 0:0:0:0" or "--grayscale".
    echo # Blank line, since HandBrakeCLI doesn't newline to _stdout_ when exiting.
    du -sh "$RIPLOG" 1>&2
        # Check the size of the log file.
        # Once, a successful rip produced a 15 GB log file due to excessive duplicate non-fatal errors.

    if [ -e "$FILE" ]
    then
        tag "${FILE}" --album "$DVDNAME" --track "$whichTrack"

        ripGrowl "${FILE}" "$DVDNAME"
    fi
}

function ripGrowl ()
{
    local WHAT="$1" \
          IDENT="$2"

    growlnotify \
        --name "rip()" \
        --title "Rip Complete" \
        --message "Encoded ${WHAT}." \
        --appIcon /Applications/HandBrake.app \
        --sticky \
        --identifier "net.gaelicWizard.rip${IDENT:+.}${IDENT:-}"
}

function tag ()
# Just a tiny wrapper around AtomicParsley(1)
{
    FILE="$1" ; shift;

    test -z "${DEBUG_DISABLE_ATOMICPARSLEY_INVOCATION}" && \
    (set -x; exec AtomicParsley "$FILE" -W "$@" )
}

function addRipOptions ()
# Adds "$@" to global array SPECIAL_RIP_OPTIONS.
{
    for option in "$@"
    do
        SPECIAL_RIP_OPTIONS["${#SPECIAL_RIP_OPTIONS[@]}"]="$option"
    done
    
    if [ -n "${SPECIAL_RIP_OPTIONS[*]}" ]
    then
        echo "WARNING: The following options will apply to all rips until SPECIAL_RIP_OPTIONS is unset:" 1>&2
        echo "${SPECIAL_RIP_OPTIONS[@]}"
    else
        echo "SPECIAL_RIP_OPTIONS is clear." 1>&2
    fi
}

function ripValidate ()
# This function takes one argument: (1) the path to a DVDMedia bundle. It reads its contents in order to determine if the initial placeholders from ripInit() have been replaced with meaningful content.
# Uses defaultsReadAtomicMetadata().
{
    local dvdmedia="$1" \
          tag whichTrack

    for whichTrack in $(defaultsReadAtomicMetadata "$dvdmedia" Disc trackList)
    do
        #TODO:FIXME: Add explicit check for _TAG_trackList_PLACEHOLDER_.
        for tag in "${theListOfAllTheTrackTags[@]}" "${theListOfAllTheTrackiTunMOVITags[@]}" "${theListOfAdditionalTrackMetadata[@]}" "${theListOfAllTheDiscTags[@]}" "${theListOfAdditionalDiscMetadata[@]}" "${theListOfAllTheAlbumTags[@]}" "${theListOfAdditionalAlbumMetadata[@]}"
        do
            if [ x"$(defaultsReadAtomicMetadatas "$dvdmedia" "$whichTrack" "$tag")" == x"_TAG_${tag}_PLACEHOLDER_" ]
            then
                echo "ripValidate(): Tag placeholders found in ${dvdmedia}." 1>&2
                return 1
            fi
        done
    done
}

function ripInit ()
# This function takes one argument: (1) the path to a DVDMedia bundle. It then writes a few plists into that directory with blank and/or generated values.
# There is code duplication with defaultsReadAtomicMetadata()
# Uses defaultsReadAtomicMetadata()
#TODO: Merge in presortTVShows.sh here. Implemented, untested.
{
    local dvdmedia="$(realpath "$1")" || return -1
        # defaults(1) requires an absolute path.

    local atomicMetadataAlbum="$dvdmedia/atomicMetadataAlbum" \
          atomicMetadataDisc="$dvdmedia/atomicMetadataDisc" \
          atomicMetadataTrack="$dvdmedia/atomicMetadataTrack-" \
          atomicMetadataShow="$dvdmedia/atomicMetadataShow" \
          VOLUME="$(defaultsReadAtomicMetadata "$dvdmedia" Disc UDFVolumeName)" \
          DVDNAME="$(basename "$(basename "$dvdmedia" .ripit)" .dvdmedia)" \
          tag trackList eachTrack
          #atomicMetadataTrack has a hyphen in it since it is expected to be duplicated per track, each with a name such as atomicMetadataTrack-2.

    local atomicPresetAlbum="$(ripMapVolumeToShow Album "${VOLUME:-$DVDNAME}" )" \
          atomicPresetDisc="$(ripMapVolumeToShow Disc "${VOLUME:-$DVDNAME}" )" \
          atomicPresetShow="$(ripMapVolumeToShow Show "${VOLUME:-$DVDNAME}" )" \
          presetTag
          # There may be differing amounts of information available for Album, Show, or Disc, so check each separately. 

    defaults write "$atomicMetadataShow" usesShow -bool false
        # Just write _anything_ into atomicMetadataShow so that the file exists.

    for tag in  "${theListOfAllTheTrackTags[@]}" \
                "${theListOfAllTheTrackiTunMOVITags[@]}" \
                "${theListOfAdditionalTrackMetadata[@]}" \
                "${theListOfSpecialTrackFlagsForHandBrake[@]}"
    do
        presetTag="$(defaults read "$atomicPresetShow" "$tag" 2>/dev/null)"

        if [ x"$presetTag" != x"" ]
        # Populate atomicMetadataShow if we have something to populate, otherwise stick the placeholder in atomicMetadataTrack.
        then
            defaults write "${atomicMetadataShow}" "$tag" "${presetTag:-_TAG_${tag:-=}_PLACEHOLDER_}"
        else
            defaults write "${atomicMetadataTrack}" "$tag" "_TAG_${tag}_PLACEHOLDER_"
        fi
    done

    for tag in  "${theListOfAllTheDiscTags[@]}" \
                "${theListOfAdditionalDiscMetadata[@]}"
    do
        presetTag="$(defaults read "$atomicPresetDisc" "$tag" 2>/dev/null)"
        defaults write "${atomicMetadataDisc}" "$tag" "${presetTag:-_TAG_${tag}_PLACEHOLDER_}"
    done

    defaults write "$atomicMetadataDisc" UDFVolumeName "${VOLUME:-$DVDNAME}" 
        # If UDFVolumeName was already set, then re-use it. Otherwise, assume the folder name.
        #TODO:FIXME: Perhaps this entire function should respect/reuse existing values?

    for tag in  "${theListOfAllTheAlbumTags[@]}" \
                "${theListOfAdditionalAlbumMetadata[@]}"
    do
        presetTag="$(defaults read "$atomicPresetAlbum" "$tag" 2>/dev/null)"
        defaults write "${atomicMetadataAlbum}" "$tag" "${presetTag:-_TAG_${tag}_PLACEHOLDER_}"
    done

    HandBrakeCLI -v0 -i "$dvdmedia" -t 0 2>&1 | uniq > "$dvdmedia/titleScan.txt"
        # Ask HandBrake to scan all available titles on the disk.
        # This gathers useful information like length, available audio/subtitle tracks, angles, &c.

    trackList=( $(awk -F '[ :]' '/^\+ title [0-9]*:/ {print $3}' "$dvdmedia/titleScan.txt") )

    defaults write "$atomicMetadataDisc" trackList  "${trackList[*]}" 
        # We need one "word" with all the array elements space-delimited, so use "*" instead of "@".

    local atomicPlist
    for atomicPlist in "${atomicMetadataTrack}.plist" "${atomicMetadataDisc}.plist" "${atomicMetadataAlbum}.plist" "${atomicMetadataShow}.plist"
    #TODO:FIXME: atomicMetadataShow.plist might not exist, and might therefore produce [harmless] errors.
    do
        plutil -convert xml1 "${atomicPlist}"
            # Convert to textual XML instead of "binary plist"
        perl -pi -e 's;</key>
	<;</key><;g' "${atomicPlist}"
            #TODO:FIXME: This line of perl is meant to bring the key/value pairs together onto one line, however it doesn't work. I might not be escaping something properly, or perl might be limited to working on one line at a time. I don't know. Oh well. Leave it in. Fix it later. 
        SetFile -a E "${atomicPlist}"
            # Hide the file extension in Finder.app
    done

    for eachTrack in "${trackList[@]}"
    do
        cp -n "${atomicMetadataTrack}.plist" "${atomicMetadataTrack}${eachTrack}.plist"
            # Copy the track template for each track.
            # Don't overwrite any track which already has atomicMetadata.
    done

    rm "${atomicMetadataTrack}.plist"
        # This will likely, though unintentionally, implicate del() from the trash package. However, that makes no difference (but is more verbose).
}

function ripMapVolumeToShow ()
# The logic from presortTVShows.sh
{
    return -1
    # Idea: store a regular expression or some such that matches a given volume name, instead of trying to match manually.
    #       perhaps using bash(1)'s own matching features?
}

function autotagTrack ()
# This function takes three arguments: (1) the path to a DVDMedia bundle (which has been initDVDMedia()'d), (2) the relevant track number, and (3) the file to tag. The bundle is expected to contain a numbered plist with metadata matching some of the tags below, which will then be passed to tag() to operate on the specified file.
# Uses defaultsReadAtomicMetadatas()
# Uses mkiTunMOVI()
# Uses tag()
{
    local dvdmedia="$1" \
          whichTrack="$2" \
          m4v="$3" \
          tag tagList tempTag iTunMOVIXML

    if [ -e "$dvdmedia/JACKET_P.jpg" ] && [ x"$(defaultsReadAtomicMetadatas "$dvdmedia" "$whichTrack" artwork)" == x"" ] && [ x"$(defaultsReadAtomicMetadatas "$dvdmedia" "$whichTrack" feature)" == x"1" ]
    # Cheap hack to ensure that only the feature gets autotag'd with artwork.
    #TODO:FIXME: Should switch to a customArtwork/needsArtwork flag.
    then
        tagList=( "${tagList[@]}" --artwork "${dvdmedia}/JACKET_P.jpg" )
    fi

    for tag in "${theListOfAllTheTrackTags[@]}" "${theListOfAllTheDiscTags[@]}" "${theListOfAllTheAlbumTags[@]}" 
    do
        tempTag="$(defaultsReadAtomicMetadatas "$dvdmedia" "$whichTrack" "$tag")"
        
        if [ x"$tempTag" != x"" ]
        then
            tagList=( "${tagList[@]}" --"$tag" "$tempTag" )
        fi
    done
    
    iTunMOVIXML="$(mkiTunMOVI "$dvdmedia" "$whichTrack")"

    tag "$m4v" "${tagList[@]}" \
             "${iTunMOVIXML:+--rDNSatom}" "${iTunMOVIXML:-}" "${iTunMOVIXML:+name=iTunMOVI}" "${iTunMOVIXML:+domain=com.apple.iTunes}"

}

function mkiTunMOVI ()
# Reads relevant information from the plists embedded in $1 and returns a plist (as a string) with iTunes metadata suitable for embedding into an MP4 container.
# Uses parseSemicolonDelimitedArray()
# Uses defaultsReadAtomicMetadatas()
{
    local plist="$(mktemp "${TMPDIR:=/tmp}/net.gaelicWizard.rip.iTunMOVI.$$.XXXXX")" || return -3
    local theType studio eachEntry theParsedArray=( )
    local dvdmedia="$1" track="$2"

    for theType in "${theListOfAllTheTrackiTunMOVITags[@]}"
    do
        parseSemicolonDelimitedArray "$(defaultsReadAtomicMetadatas "$dvdmedia" "$track" "$theType")" || return -2

        for eachEntry in "${theParsedArray[@]}"
        do
            defaults write "$plist" "$theType" -array-add '{ name = "'"${eachEntry}"'"; }' || return -1
        done
    done

    if studio="$(defaultsReadAtomicMetadatas "$dvdmedia" "$track" studio)"
    then
        defaults write "$plist" studio "$studio"
        # This should overwrite any array written just above.
    fi

    if test -e "${plist}.plist"
    # If we generated a plist, post-process it a bit.
    then
        plutil -convert xml1 -- "${plist}.plist" || return -2

        cat "${plist}.plist"
        command rm -f "${plist}.plist"
    fi
}

function parseSemicolonDelimitedArray ()
# Parses $1 for a semicolon delimited array, and populates the global theParsedArray with the result.
{
    local theUnparsedArray="$1"
    theParsedArray=( ) # Blank the global array.
    local eachEntry i=1
    
    while eachEntry="$(echo "${theUnparsedArray}" | awk -F ';' '{print $'"$i"'}')"
    do
        if [ "${eachEntry}" == "" ]
        then
            break
        fi
    
        if [ "${eachEntry:0:1}" == " " ]
        then
            eachEntry="${eachEntry:1:${#eachEntry}}"
        fi
        
        theParsedArray=( "${theParsedArray[@]}" "${eachEntry}" )
        i=$(( $i + 1 ))
    done
}


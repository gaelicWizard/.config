#!/bin/bash -c 'this file is not executable. source it.'

import trash || return -1
    # Import my trash package for
        # del

export AP_PADDING="DEFAULT_PAD=8192:MIN_PAD=0:MAX_PAD=8192"
export PIC_OPTIONS="removeTempPix:AddBothPix=true"
    # Set up a bunch of defaults for AtomicParsley(1) so that finishing up
    #  the tagging process is later is less painful.

##
# tagging globals
theListOfAllTheTrackTags=( title artist description genre year copyright advisory stik contentRating TVEpisode TVEpisodeNum composer comment )
theListOfAllTheTrackiTunMOVITags=( studio cast codirectors directors producers screenwriters executiveproducers supervisingproducers assistantproducers associateproducers )
theListOfAdditionalTrackMetadata=( ratingAdvisory audioList angleList subtitleList feature usesShow )
theListOfAllTheDiscTags=( disk )
theListOfAdditionalDiscMetadata=( maxtrack trackList UDFVolumeName diskid )
theListOfAllTheAlbumTags=( TVShowName TVSeasonNum albumArtist album year TVNetwork artwork )
theListOfAdditionalAlbumMetadata=( UPC ISBN ASIN label maxdisk )
# end tagging globals
##

function ripDebug ()
{
    export DEBUG_DISABLE_HANDBRAKE_INVOCATION=DEBUG_DISABLE_HANDBRAKE_INVOCATION
    export DEBUG_DISABLE_ATOMICPARSLEY_INVOCATION=DEBUG_DISABLE_ATOMICPARSLEY_INVOCATION
    export DO_NOT_TWEET_RIPS=DO_NOT_TWEET_RIPS
    export DEBUG_DISABLE_TAR_INVOCATION=DEBUG_DISABLE_TAR_INVOCATION
    
    echo "$DEBUG_DISABLE_HANDBRAKE_INVOCATION; $DEBUG_DISABLE_ATOMICPARSLEY_INVOCATION; $DO_NOT_TWEET_RIPS; $DEBUG_DISABLE_TAR_INVOCATION" 1>&2
}

function ripEm ()
# Loops ripIt for each "$@"
{
    local movie
    for movie in "$@"
    do
        ripIt "$movie" || return
    done
}

function ripIt ()
# Invokes ripTitles() on $1 specifying which titles to rip from atomicMetadata(…), then autotag() on same, then tar(1)s and moves same to trash.
# Uses ripTitles()
# Uses autotag()
# Uses del #trash
# Uses defaultsReadAtomicMetadata()
{
    local dvdmedia="$1"

    time ripTitles "${dvdmedia}" $(defaultsReadAtomicMetadata "$dvdmedia" Disc trackList) || return

    autotag "$dvdmedia" || return

    test -z "${DEBUG_DISABLE_TAR_INVOCATION:-}" && \
        {
            tar cvf "$(basename "$dvdmedia" .dvdmedia).tar" -C "$(dirname "$dvdmedia")" "$(basename "$dvdmedia")" || return
            del "$dvdmedia" || return
        } || test -n "${DEBUG_DISABLE_TAR_INVOCATION:-}" # Workaround: we don't want to "fail" (return non-zero) if we are _deliberately_ skipping tar(1) invocation.
}

function ripBleach ()
# ripBleach /path/to/VIDEO_TS/or/parent
{
#sanity
    if [ x"${1:-}" == x"" ]
    then
        echo "ripBleach /path/to/Bleach Volume X.dvdmedia" 1>&2
        return -1
    fi
#insanity

    local RET=0
    DVD="$1"  ; shift;
    AUDIO="1:English Dub,2:Original Japanese" # Encode audio tracks 1 and 2 (English and Japanese)

    local RESERVED_SPECIAL_RIP_OPTIONS=( "${SPECIAL_RIP_OPTIONS[@]}" )
    addRipOptions --markers="$DVD/../Bleach.chapters"

    time ripChapters "$DVD" "$AUDIO" "1:1-4" "2:6-9" "3:11-14" "4:16-19" "5:21-24" || RET="$?"
        # It is expected that 21-24 will fail on _most_ (but not all) volumes.
        # When 21-24 "fails", a short (<10s) logo-only chapter will be encoded.
        # (The skipped chapters are advertisements for more bleach...)

    autotag "$1"

    unset SPECIAL_RIP_OPTIONS
    addRipOptions "${RESERVED_SPECIAL_RIP_OPTIONS[@]}"
    
    return "$RET"
}

function defaultsReadAtomicMetadatas ()
# Uses defaultsReadAtomicMetadata() to repeatedly read various atomicMetadataPlists until a value is found for $3
{
    local dvdmedia="$1"; shift
    local track="$1"; shift
    
    # The order of calls is important here. 
    # Track should override Show, which should override Disc, which should override Album. 
    # Without overrides, they should fall-through in that order.

    defaultsReadAtomicMetadata "$dvdmedia" Track "$track" "$@" && return # return on success
        # since $3 is only read by defaultsReadAtomicMetadata() when $2 is Track, we have to special-case it.

    if [ x"$(defaultsReadAtomicMetadata "$dvdmedia" Track "$track" usesShow)" == x"1" ]
    # Show is special-cased because bonus material in an album might not share the same show metadata as the actual features.
    then
        defaultsReadAtomicMetadata "$dvdmedia" Show "$@" && return # return on success
    fi

    local metadataType
    for metadataType in Disc Album
    do
        defaultsReadAtomicMetadata "$dvdmedia" "$metadataType" "$@" && return # return on success
    done
}

function defaultsReadAtomicMetadata ()
# Generates a full path (using $1) (minus .plist extension) to the given type of metadata ($2 and maybe $3), and uses defaults(1) to read $@ from it.
# There is code duplication with initDVDMedia().
{
    local dvdmedia="$(realpath "$1")" || return -1
        # This requires a working realpath.
    shift # drop $dvdmedia from "$@"
    local whichAtomicMetadata="$1"; shift
    if [ x"$whichAtomicMetadata" == x"Track" ]
    then
        local whichAtomicMetadataTrack="${1:-}"; shift
    fi

    local atomicMetadataPlist="$dvdmedia/atomicMetadata${whichAtomicMetadata}${whichAtomicMetadataTrack:+-}${whichAtomicMetadataTrack:-}"

    defaults read "$atomicMetadataPlist" "$@"
}

function ripTitles ()
# Invokes rip() on "$1" for each "$@".
# Uses rip()
# Uses defaultsReadAtomicMetadatas()
{
    local dvdmedia="$1"; shift
    local title

    for title in "$@"
    do
        rip "$dvdmedia" "$(defaultsReadAtomicMetadatas "$dvdmedia" "$title" audioList)" "$title" || return
                    # `break' here should result in the return value of rip being used as the return value here… but it doesn't seem to…
    done
}

function ripAnglesOld ()
{
    local RET=0
    local ANGLE_TITLE ANGLE_TRACK ANGLE
    local ANGLE_LIST="${1:-}"; shift
    local angle_track
    
    if [ x"$ANGLE_LIST" == x"" ]
    then
        rip "$@"
        return "$?"
        # Short Circuit
    fi
    
    local TMPIFS="$IFS"; IFS=","
    for angle_track in $ANGLE_LIST
    do
        local RESERVED_SPECIAL_RIP_OPTIONS=( "${SPECIAL_RIP_OPTIONS[@]}" )
        addRipOptions --angle "${angle_track%:*}"

        IFS="$TMPIFS"
        
        rip "$@" "${angle_track#*:}:" || { RET="$?"; break; }
        # Don't specify any chapters, but specify a name for the chapters.
        
        TMPIFS="$IFS"; IFS=","
        
        unset SPECIAL_RIP_OPTIONS
        addRipOptions "${RESERVED_SPECIAL_RIP_OPTIONS[@]}"
    done
    IFS="$TMPIFS"
    unset angle_track TMPIFS
    
    return "${RET:-0}"
}

function ripChapters ()
# ripChapters /path/to/VIDEO_TS/or/parent 1:English,2:Commentary chapters1:2-4 chapters2:6-9
{
    local DVD="$1"  ; shift;
    if test -n "$1"
    then
        local AUDIO="$1"
    fi
    shift
    local TITLE_PLACEHOLDER="" # blank; rip() will use longest title

    for chapter in "$@"
    do
        rip "$DVD" "$AUDIO" "$TITLE_PLACEHOLDER" "$chapter" || break # break here should result in the return value of rip being used as the return value here
    done
}

function newRip ()
# rip() /path/to/VIDEO_TS/.. 7
{
    local dvdmedia="$1" # /path/to/VIDEO_TS's parent
    local whichTrack="$2" # integer
    local whichChapters="${3:-}" # 1:1-4 or highlights:2-5,7,13
    
    ripSanity "$dvdmedia" "$whichTrack" || ripFail "ripSanity"

    local audioList="$(defaultsReadAtomicMetadatas "$dvdmedia" "$whichTrack" audioList)" || ripFail "audioList"
    local subtitleList="$(defaultsReadAtomicMetadatas "$dvdmedia" "$whichTrack" subtitleList)" || ripFail "subtitleList"

    local DVDNAME="$(defaultsReadAtomicMetadatas "$dvdmedia" "$whichTrack" UDFVolumeName)" || ripFail "UDFVolumeName"
        # Use $DVDNAME as the base name for the output file (see $FILE below).

    local chapterList="${whichChapters#*:}" # everything after the first colon
    local chapterName="${whichChapters%%:*}" # everything before the first colon
        # There should only be one colon. 
        #TODO:FIXME: Chapter name should be extracted from $dvdmedia/chapters-$whichTrack.txt

    local audioNames="$(ripParseAudioNames "$audioList")"
    local audioTracks="$(ripParseAudioTracks "$audioList")"
    
    local subtitleNames="$(ripParseAudioNames "$subtitleList")"
    local subtitleTracks="$(ripParseAudioTracks "$subtitleList")"

    FILE="${DVDNAME}-${whichTrack}${chapterName:+-}${chapterName:-}.m4v"
        # e.g. DVD_VIDEO-1-Triumph.m4v
#Do it
    local RET=0
    test -z "${DEBUG_DISABLE_HANDBRAKE_INVOCATION:-}" && (
        test -e "$FILE" && del "$FILE"; \
        set -x; \
    exec HandBrakeCLI -v"${HANDBRAKE_DEBUG_LEVEL:-1}" \
        --preset "Universal" \
        --input "$dvdmedia" \
        --title "$whichTrack" \
        "${chapterList:+--chapters}" "${chapterList:-}" \
        --previews 30 \
        --output "$FILE" \
        --markers"${dvdmedia}/chapters-${whichTrack}.txt" \
        --ipod-atom \
        --detelecine \
        --vfr \
        --audio "$audioTracks" \
        --aencoder "$(IFS=,; for i in $audioTracks; do echo -n ca_aac,; done)" \
        "${audioNames:+--aname}" "${audioNames:-}" \
        "${SPECIAL_RIP_OPTIONS[@]}" \
    2>> ~/Library/Logs/net.gaelicWizard.rip/"$DVDNAME".log ) || return
        # Universal preset to activate sensible defaults.
        # Use the longest title, if none specified.
        # Only encode selected chapters, if specified.
        # Generate 30 previews, b/c I hope it will improve autocropping.
            # The number of previews generated is related to the accuracy of the autocropper, but seemingly only two previews are used.
        # Import chapter titles from CSV file, if available.
        # iPod atom, so that 5.5G iPods will accept the media.
        # Detelecine, always. Unclear why HandBrake doesn't just do this.
            # HandBrake documentation for the framerate setting implies that HandBrake does, in fact, detelecine by default, but it lies.
        # Variable Frame Rate is the default, but didn't used to be.
            # This option disappeared _completely_ during 0.9.3
        # Enable selected audio tracks from the DVD.
        # Encode them all to AAC, accepting default Dolby Pro Logic 2 encoding.
            # AAC is the default, so this line might be entirely unneeded.
            # However, the Universal preset duplicates track 1 to track 2 as pass-thru "AC-3", so it might be needed to _return_ to defaults. TODO: Untested, actually.
        # Name the selected audio tracks, e.g. "Director's Commentary".
        # Add any special out-of-band flags to HandBrake, such as "--crop 0:0:0:0" or "--grayscale".

    if [ -e "$FILE" ]
    then
        growlnotify \
            --name "rip()" \
            --title "Rip Complete" \
            --message "Encoded ${FILE}." \
            --appIcon /Applications/HandBrake.app \
            --sticky \
            --identifier net.gaelicWizard.rip
    
        if [ x"$(defaultsReadAtomicMetadatas "$dvdmedia" "$whichTrack" feature)" != x"11" ]
        #TODO:FIXME: need a way to check that a given track is the _only_ feature on a disc, which is not always true.
        then
            local TRACK="$whichTrack"
        fi
        
        #Tag some basic housekeeping
        tag "${FILE}" --album "$DVDNAME" "${TRACK:+--track}" "$TRACK"
    else
        echo "$FUNCNAME: ${FILE} does not appear to have been created." 1>&2
        return -2
    fi
    
    addRipOptions # If any SPECIAL_RIP_OPTIONS are set, then issue a warning.
}

function rip ()
# rip /path/to/VIDEO_TS/.. 1:English,2:Commentary title7 chapters1:2-4
{
##TODO: Subtitles. Goal: Star Wars prequels show subtitles during appropriate scenes. Use --subtitle-forced and/or --native-language.


#Process arguments
    local DVD="${1:-/dev/null}"
        # The path to the VIDEO_TS folder or its parent
    local AUDIO_LIST="${2:-}"
        # Which audio tracks to encode. If unspecified, may be inherited.
    local TITLE="${3:-}"
        # Which title to rip. If unspecified, then the longest title is used.
    local CHAPLIST="${4:-}"
        # NOT HANDBRAKE's FORMAT. TODO:FIXME:document
    
    function ripUsage ()
    # nested function FTW
    {
        echo "rip /path/to/DVD 1:English,2:Commentary 7 ep3:2-4" 1>&2
    }

    if ! [ -d "$DVD/VIDEO_TS" ]
    then
        echo "Please specify the path to the DVD (parent of VIDEO_TS) as the first argument." 1>&2
        ripUsage
        return -1
    fi
    
    if test -z "${AUDIO_LIST:-}" && test -z "${AUDIO:-}"
    then
        echo "Please specify the audio track list as the second argument." 1>&2
        ripUsage
        return -2
    fi
    
    #TODO:FIXME: More sanity checks

#Derive settings from arguments, where needed
    local DVDNAME="$(basename "$DVD" .dvdmedia)"
    local CHAPTITL="${CHAPLIST%:*}"
        # What "title" to call this chapter-set
    local CHAPTERS="${CHAPLIST#*:}"
        # What chapters to rip
        # TODO: FIXME: Tested, but unverified
    if [ "${FEATURE:--1}" -eq "${TITLE:-0}" ]
    then
        local DVDNAMEWITHTITLEBUTNOTCHAPTER="$DVDNAME"
        local TRACK=
        #TODO:FIXME:HACK for --longest specified as --title X
    else
        local DVDNAMEWITHTITLEBUTNOTCHAPTER="${DVDNAME}${TITLE:+-}${TITLE}"
        local TRACK="${TITLE:-}"
    fi
    local DVDNAMEWITHTITLE="${DVDNAMEWITHTITLEBUTNOTCHAPTER}${CHAPTITL:+-}${CHAPTITL}"
        # What's the name-track-chapterset of this disc?
    local TRACK="${CHAPTITL:-$TRACK}"
        # TODO:FIXME: Might cause a problem when CHAPTITL isn't numeric
    local AUDIO="${AUDIO:-1,2,3,4,5,6,7,8}"
        # Which audio tracks to encode, see HandBrakeCLI(1), defaulting to all.
        # This will always fail, unless the DVD has all 8 audio tracks, since HandBrake crashes when asked to encode a non-existent track.
        # Inherit a pre-specified $AUDIO, if available.
    local audio_track
    local TMPIFS="$IFS"; IFS=","
    for audio_track in $AUDIO_LIST
    do
        local AUDIO_TITLES="${AUDIO_TITLES:-}${AUDIO_TITLES:+,}${audio_track#*:}"
            # What "title" to call this audio track
        local AUDIO_TRACKS="${AUDIO_TRACKS:-}${AUDIO_TRACKS:+,}${audio_track%:*}"
            # What audio tracks to encode
            # TODO: FIXME: Untested
        local AUDIO="$AUDIO_TRACKS"
    done
    IFS="$TMPIFS"
    unset audio_track TMPIFS
    local FILE="${DVDNAMEWITHTITLE}.m4v"
#    local FILE="${HOME}/Movies/HandBrake/${DVDNAMEWITHTITLE}.m4v"
        # Where to save the output. Store it in ~/Movies/HandBrake with the name of $DVD.
        # Use HandBrake's naming convention, extending it for chapters.

#Derive constants
    local MARKERS="${DVD}/chapters${TITLE:+-}${TITLE:-}.txt"
        # /path/to/DVD/chapters/list/in/CSV
    local AUDIO_ENC="$(IFS=,; for i in $AUDIO; do echo -n ca_aac,; done)"
        # This is, sadly, necessary to work around a bug in HandBrake which will duplicate the last track specified in $AUDIO to until all eight tracks are filled. Bug filed and rejected. :-/

#Do it
    local RET=0
    test -z "${DEBUG_DISABLE_HANDBRAKE_INVOCATION:-}" && (
        test -e "$FILE" && del "$FILE"; \
        set -x; \
    exec HandBrakeCLI -v"${HANDBRAKE_DEBUG_LEVEL:-1}" \
        --preset "Universal" \
        --input "$DVD" \
        "${TITLE:+--title}" "${TITLE:---longest}" \
        "${CHAPTERS:+--chapters}" "${CHAPTERS:-}" \
        --previews 30 \
        --output "$FILE" \
        --markers"${MARKERS:+=}${MARKERS:-}" \
        --ipod-atom \
        --detelecine \
        --vfr \
        --audio "$AUDIO" \
        --aencoder "$AUDIO_ENC" \
        "${AUDIO_TITLES:+--aname}" "${AUDIO_TITLES:-}" \
        "${SPECIAL_RIP_OPTIONS[@]}" \
    2>> ~/Library/Logs/net.gaelicWizard.rip/"$DVDNAME".log ) || RET="$?"
        # Universal preset to activate sensible defaults.
        # Use the longest title, if none specified.
        # Only encode selected chapters, if specified.
        # Generate 30 previews, b/c I hope it will improve autocropping.
            # The number of previews generated is related to the accuracy of the autocropper, but seemingly only two previews are used.
        # Import chapter titles from CSV file, if available.
        # iPod atom, so that 5.5G iPods will accept the media.
        # Detelecine, always. Unclear why HandBrake doesn't just do this.
            # HandBrake documentation for the framerate setting implies that HandBrake does, in fact, detelecine by default, but it lies.
        # Variable Frame Rate is the default, but didn't used to be.
            # This option disappeared _completely_ during 0.9.3
        # Enable selected audio tracks from the DVD.
        # Encode them all to AAC, accepting default Dolby Pro Logic 2 encoding.
            # AAC is the default, so this line might be entirely unneeded.
            # However, the Universal preset duplicates track 1 to track 2 as pass-thru "AC-3", so it might be needed to _return_ to defaults. TODO: Untested, actually.
        # Name the selected audio tracks, e.g. "Director's Commentary".
        # Add any special out-of-band flags to HandBrake, such as "--crop 0:0:0:0" or "--grayscale".

    if [ "${RET:-0}" -ne 0 ]
    then
        return "$RET"
    fi

    if [ -e "$FILE" ]
    then
        #Tweet about it
        if [ -z "${DO_NOT_TWEET_RIPS:-}" ] && [ "${FEATURE:--1}" -eq "${TITLE:-0}" ]
        then
            updateStatus.sh "encoded ${NAME[$TITLE]:-}." &
        fi
    
    growlnotify \
            --name "rip()" \
            --title "Encode Complete" \
            --message "${NAME[$TITLE]:-$DVDNAME} encoded to $(basename "${FILE}")." \
            --appIcon /Applications/HandBrake.app \
            --sticky \
            --identifier net.gaelicWizard.rip
    
        if test "${TITLE:--1}" -eq "${FEATURE:-0}"
        then
            TRACK=
            # Don't embed the track number if this is "the" [only] movie on the disc.
        fi
        
        #Tag some basic housekeeping
        tag "${FILE}" --album "$DVDNAME" "${TRACK:+--track}" "$TRACK"
    else
        echo "$FUNCNAME: ${FILE} does not appear to have been created." 1>&2
        return -2
    fi
    
    addRipOptions # If any SPECIAL_RIP_OPTIONS are set, then issue a warning.
}

function tag ()
# Just a tiny wrapper around AtomicParsley(1)
{
    FILE="$1" ; shift;
    
    test -z "${DEBUG_DISABLE_ATOMICPARSLEY_INVOCATION}" && \
    (set -x; exec AtomicParsley "$FILE" -W "$@" )
}

function addRipOptions ()
# Adds "$@" to global array SPECIAL_RIP_OPTIONS.
{
    for option in "$@"
    do
        SPECIAL_RIP_OPTIONS["${#SPECIAL_RIP_OPTIONS[@]}"]="$option"
    done
    
    if [ -n "${SPECIAL_RIP_OPTIONS[*]}" ]
    then
        echo "WARNING: The following options will apply to all rips until SPECIAL_RIP_OPTIONS is unset:" 1>&2
        echo "${SPECIAL_RIP_OPTIONS[@]}"
    else
        echo "SPECIAL_RIP_OPTIONS is clear." 1>&2
    fi
}

function initBleachBundle ()
# This function takes one argument: (1) the path to a DVDMedia bundle whose name begins with "Bleach", which is presumed to be a volume in the Bleach anime series. An atomicMetadataShow.plist is copied in, an a chapters list is symlink'd in.
# Uses initDVDMedia()
{
    if [ x"${1:0:6}" != x"Bleach" ]
    then
        echo "Usage: $FUNCNAME 'Bleach Volume 25.dvdmedia'" 1>&2
        return -1
    fi

    initDVDMedia "$1"

    ln -s "../Bleach.chapters" "$1"/chapters-1.txt

    cp ~/Library/"Application Support"/net.gaelicWizard.rip.localized/Bleach.plist "${1}/atomicMetadataShow.plist"
}

function initDVDMedia ()
# This function takes one argument: (1) the path to a DVDMedia bundle. It then writes a few plists into that directory with blank and/or generated values.
# There is code duplication with defaultsReadAtomicMetadata()
{
    local dvdmedia="$1"
    if [ x"${1:0:1}" != x"/" ]
    # Make sure that $dvdmedia is an absolute path, in order to work around weird defaults(1) behaviour.
    then
        dvdmedia="$(pwd)/$1"
        # Don't trust $PWD to be set, since it is not read-only.
    else
        dvdmedia="$1"
    fi

    local atomicMetadataAlbum="$dvdmedia/atomicMetadataAlbum" \
          atomicMetadataDisc="$dvdmedia/atomicMetadataDisc" \
          atomicMetadataTrack="$dvdmedia/atomicMetadataTrack-" \
          tag 
          #atomicMetadataTrack has a hyphen in it since it is expected to be duplicated a number of times.

    for tag in "${theListOfAllTheTrackTags[@]}" "${theListOfAllTheTrackiTunMOVITags[@]}" "${theListOfAdditionalTrackMetadata[@]}"
    do
        defaults write "${atomicMetadataTrack}" "$tag" "_TAG_${tag}_PLACEHOLDER_"
    done
    
    for tag in "${theListOfAllTheDiscTags[@]}" "${theListOfAdditionalDiscMetadata[@]}"
    do
        defaults write "${atomicMetadataDisc}" "$tag" "_TAG_${tag}_PLACEHOLDER_"
    done
    
    defaults write "$atomicMetadataDisc" UDFVolumeName "$(basename "$dvdmedia" .dvdmedia)"
    
    for tag in "${theListOfAllTheAlbumTags[@]}" "${theListOfAdditionalAlbumMetadata[@]}"
    do
        defaults write "${atomicMetadataAlbum}" "$tag" "_TAG_${tag}_PLACEHOLDER_"
    done




    local atomicPlist
    for atomicPlist in "${atomicMetadataTrack}.plist" "${atomicMetadataDisc}.plist" "${atomicMetadataAlbum}.plist"
    do
        plutil -convert xml1 "${atomicPlist}"
        perl -pi -e 's;</key>
	<;</key><;g' "${atomicPlist}"
            #TODO:FIXME: This line of perl is meant to bring the key/value pairs together onto one line, however it doesn't work. I might not be escaping something properly, or perl might be limited to working on one line at a time. I don't know. Oh well. Leave it in. Fix it later. 
    done
    
    SetFile -a T "${atomicMetadataTrack}.plist"
        # When double-clicked in Finder, it will be duplicated and the duplicate opened instead of the original.

    HandBrakeCLI -v0 -i "$dvdmedia" -t 0 2> "$dvdmedia/titleScan.txt"
        # Ask HandBrake to scan all available titles on the disk.
        # This gathers useful information like length, available audio/subtitle tracks, angles, &c.
}

function autotag ()
# This function takes one argument: (1) the path to a DVDMedia bundle (which has been initDVDMedia()'d). defaultsReadAtomicMetadata() reads a list of tracks (which should have been already encoded). autoTagTrack() is then invoked for each track using file names generated from the DVDMedia bundle file name.
# Uses autoTagTrack()
# Uses defaultsReadAtomicMetadata()
{
    local dvdmedia="$1"
    local trackList="$(defaultsReadAtomicMetadata "$dvdmedia" Disc trackList)" \
          DVDNAME="$(basename "$dvdmedia" .dvdmedia)" # ripOld().
          #DVDNAME="$(defaultsReadAtomicMetadatas "$dvdmedia" "$whichTrack" UDFVolumeName)" || ripFail "UDFVolumeName" # newRip().

    local aTrack
    for aTrack in $trackList
    do
        autotagTrack "$dvdmedia" "$aTrack" "$DVDNAME-$aTrack.m4v" || return
    done
}

function autotagTrack ()
# This function takes three arguments: (1) the path to a DVDMedia bundle (which has been initDVDMedia()'d), (2) the relevant track number, and (3) the file to tag. The bundle is expected to contain a numbered plist with metadata matching some of the tags below, which will then be passed to tag() to operate on the specified file.
# Uses defaultsReadAtomicMetadatas()
# Uses mkiTunMOVI()
# Uses tag()
{
    local dvdmedia="$1" \
          whichTrack="$2" \
          m4v="$3" \
          tag tagList tempTag iTunMOVIXML

    if [ -e "$dvdmedia/JACKET_P.jpg" ] && [ x"$(defaultsReadAtomicMetadatas "$dvdmedia" "$whichTrack" artwork)" == x"" ] && [ x"$(defaultsReadAtomicMetadatas "$dvdmedia" "$whichTrack" feature)" == x"1" ]
    # Cheap hack to ensure that only the feature gets autotag'd with artwork.
    # Should switch to a customArtwork/needsArtwork flag.
    then
        tagList=( "${tagList[@]}" --artwork "${dvdmedia}/JACKET_P.jpg" )
    fi

    for tag in "${theListOfAllTheTrackTags[@]}" "${theListOfAllTheDiscTags[@]}" "${theListOfAllTheAlbumTags[@]}" 
    do
        tempTag="$(defaultsReadAtomicMetadatas "$dvdmedia" "$whichTrack" "$tag")"
        
        if [ x"$tempTag" != x"" ]
        then
            tagList=( "${tagList[@]}" --"$tag" "$tempTag" )
        fi
    done
    
    iTunMOVIXML="$(mkiTunMOVI "$dvdmedia" "$whichTrack")"

    tag "$m4v" "${tagList[@]}" \
             "${iTunMOVIXML:+--rDNSatom}" "${iTunMOVIXML:-}" "${iTunMOVIXML:+name=iTunMOVI}" "${iTunMOVIXML:+domain=com.apple.iTunes}"

}

function mkiTunMOVI ()
# Reads relevant information from the plists embedded in $1 and returns a plist (as a string) with iTunes metadata suitable for embedding into an MP4 container.
# Uses parseSemicolonDelimitedArray()
# Uses defaultsReadAtomicMetadatas()
{
    local plist="$(mktemp "${TMPDIR:=/tmp}/net.gaelicWizard.rip.iTunMOVI.$$.XXXXX")" || return -3
    local theType studio eachEntry theParsedArray=( )
    local dvdmedia="$1" track="$2"

    for theType in "${theListOfAllTheTrackiTunMOVITags[@]}"
    do
        parseSemicolonDelimitedArray "$(defaultsReadAtomicMetadatas "$dvdmedia" "$track" "$theType")" || return -2

        for eachEntry in "${theParsedArray[@]}"
        do
            defaults write "$plist" "$theType" -array-add '{ name = "'"${eachEntry}"'"; }' || return -1
        done
    done

    if studio="$(defaultsReadAtomicMetadatas "$dvdmedia" "$track" studio)"
    then
        defaults write "$plist" studio "$studio"
        # This should overwrite any array written just above.
    fi

    if test -e "${plist}.plist"
    # If we generated a plist, post-process it a bit.
    then
        plutil -convert xml1 -- "${plist}.plist" || return -2

        cat "${plist}.plist"
        command rm -f "${plist}.plist"
    fi
}

function parseSemicolonDelimitedArray ()
# Parses $1 for a semicolon delimited array, and populates the global theParsedArray with the result.
{
    local theUnparsedArray="$1"
    theParsedArray=( ) # Blank the global array.
    local eachEntry i=1
    
    while eachEntry="$(echo "${theUnparsedArray}" | awk -F ';' '{print $'"$i"'}')"
    do
        if [ "${eachEntry}" == "" ]
        then
            break
        fi
    
        if [ "${eachEntry:0:1}" == " " ]
        then
            eachEntry="${eachEntry:1:${#eachEntry}}"
        fi
        
        theParsedArray=( "${theParsedArray[@]}" "${eachEntry}" )
        i=$(( $i + 1 ))
    done
}


#!/bin/bash -c 'this file is not executable. source it.'

import trash || return -1
    # Import my trash package for
        # del

export AP_PADDING="DEFAULT_PAD=8192:MIN_PAD=0:MAX_PAD=8192"
export PIC_OPTIONS="removeTempPix:AddBothPix=true"
    # Set up a bunch of defaults for AtomicParsley(1) so that finishing up
    #  the tagging process is later is less painful.

##
# tagging globals
theListOfAllTheTrackTags=( title artist description genre year copyright advisory stik contentRating TVEpisode TVEpisodeNum composer comment )
theListOfAllTheTrackiTunMOVITags=( studio cast codirectors directors producers screenwriters executiveproducers supervisingproducers )
theListOfAdditionalTrackMetadata=( ratingAdvisory audioList angleList )
theListOfAllTheDiscTags=( disk )
theListOfAdditionalDiscMetadata=( maxtrack trackList UDFVolumeName diskid )
theListOfAllTheAlbumTags=( TVShowName TVSeasonNum albumArtist album year TVNetwork artwork )
theListOfAdditionalAlbumMetadata=( UPC ISBN ASIN label maxdisk )
# end tagging globals
##

function ripDebug ()
{
    export DEBUG_DISABLE_HANDBRAKE_INVOCATION=DEBUG_DISABLE_HANDBRAKE_INVOCATION
    export DEBUG_DISABLE_ATOMICPARSLEY_INVOCATION=DEBUG_DISABLE_ATOMICPARSLEY_INVOCATION
    export DO_NOT_TWEET_RIPS=DO_NOT_TWEET_RIPS
    export DEBUG_DISABLE_TAR_INVOCATION=DEBUG_DISABLE_TAR_INVOCATION
    
    echo "$DEBUG_DISABLE_HANDBRAKE_INVOCATION; $DEBUG_DISABLE_ATOMICPARSLEY_INVOCATION; $DO_NOT_TWEET_RIPS; $DEBUG_DISABLE_TAR_INVOCATION" 1>&2
}

function ripEm ()
# Loops ripIt for each "$@"
{
    local movie
    for movie in "$@"
    do
        ripIt "$movie" || return
    done
}

function ripIt ()
# Invokes ripTitles() on "$1" specifying which titles to rip, then autotag on same, then tar(1)s and moves same to trash.
# Uses ripTitles()
# Uses autotag()
# Uses del #trash
{
    local dvdmedia="$1"
    if [ x"${1:0:1}" != x"/" ]
    # Make sure that $dvdmedia_path is an absolute path, in order to work around weird defaults(1) behaviour.
    then
        dvdmedia_path="$(pwd)/$1"
        # Don't trust $PWD to be set, even though it should _always_ be.
    else
        dvdmedia_path="$1"
    fi
    local atomicMetadataDisc="$dvdmedia_path/atomicMetadataDisc"

    ripTitles "${dvdmedia}" $(defaults read "$atomicMetadataDisc" trackList) || return

    autotag "$dvdmedia" || return
        # newAutoTag() not the old autotag.

    test -z "${DEBUG_DISABLE_TAR_INVOCATION:-}" && \
        {
            tar cvf "$(basename "$dvdmedia" .dvdmedia).tar" -C "$(dirname "$dvdmedia")" "$(basename "$dvdmedia")" || return
            del "$dvdmedia" || return
        } || test -n "${DEBUG_DISABLE_TAR_INVOCATION:-}" # Workaround: we don't want to "fail" (return non-zero) if we are _deliberately_ skipping tar(1) invocation.
}

function ripBleach ()
# ripBleach /path/to/VIDEO_TS/or/parent
{
#sanity
    if [ x"${1:-}" == x"" ]
    then
        echo "ripBleach /path/to/Bleach Volume X.dvdmedia" 1>&2
        return -1
    fi
#insanity

    local RET=0
    DVD="$1"  ; shift;
    AUDIO="1:English Dub,2:Original Japanese" # Encode tracks 1 and 2 (English and Japanese)

    local RESERVED_SPECIAL_RIP_OPTIONS=( "${SPECIAL_RIP_OPTIONS[@]}" )
    addRipOptions --markers="$DVD/../Bleach.chapters"

    ripChapters "$DVD" "$AUDIO" "1:1-4" "2:6-9" "3:11-14" "4:16-19" "5:21-24" || RET="$?"
        # It is expected that 21-24 will fail on _most_ (but not all) volumes.
        # When 21-24 "fails", a short (<10s) logo-only chapter will be encoded.
        # (The skipped chapters are advertisements for more bleach...)

    unset SPECIAL_RIP_OPTIONS
    addRipOptions "${RESERVED_SPECIAL_RIP_OPTIONS[@]}"
    
    return "$RET"
}

function ripTitles ()
# Invokes rip() on "$1" for each "$@".
# Uses rip()
{
    local dvdmedia="$1" title
    if [ x"${1:0:1}" != x"/" ]
    # Make sure that $dvdmedia_path is an absolute path, in order to work around weird defaults(1) behaviour.
    then
        dvdmedia_path="$(pwd)/$1"
        # Don't trust $PWD to be accurate.
    else
        dvdmedia_path="$1"
    fi
    local atomicMetadataTrack="$dvdmedia_path/atomicMetadataTrack"
    shift # discard $1, now that we've had our way with it.

    for title in "$@"
    do
        rip "$dvdmedia" "$(defaults read "${atomicMetadataTrack}-$title" audioList)" "$title" || return "$?" 
                    # `break' here should result in the return value of rip being used as the return value hereâ€¦ but it doesn't
    done
}

function ripAngles ()
{
    local RET=0
    local ANGLE_TITLE ANGLE_TRACK ANGLE
    local ANGLE_LIST="${1:-}"; shift
    local angle_track
    
    if [ x"$ANGLE_LIST" == x"" ]
    then
        rip "$@"
        return "$?"
        # Short Circuit
    fi
    
    local TMPIFS="$IFS"; IFS=","
    for angle_track in $ANGLE_LIST
    do
        local RESERVED_SPECIAL_RIP_OPTIONS=( "${SPECIAL_RIP_OPTIONS[@]}" )
        addRipOptions --angle "${angle_track%:*}"

        IFS="$TMPIFS"
        
        rip "$@" "${angle_track#*:}:" || { RET="$?"; break; }
        # Don't specify any chapters, but specify a name for the chapters.
        
        TMPIFS="$IFS"; IFS=","
        
        unset SPECIAL_RIP_OPTIONS
        addRipOptions "${RESERVED_SPECIAL_RIP_OPTIONS[@]}"
    done
    IFS="$TMPIFS"
    unset angle_track TMPIFS
    
    return "${RET:-0}"
}

function ripChapters ()
# ripChapters /path/to/VIDEO_TS/or/parent 1:English,2:Commentary chapters1:2-4 chapters2:6-9
{
    local DVD="$1"  ; shift;
    if test -n "$1"
    then
        local AUDIO="$1"
    fi
    shift
    local TITLE_PLACEHOLDER="" # blank; rip() will use longest title

    for chapter in "$@"
    do
        rip "$DVD" "$AUDIO" "$TITLE_PLACEHOLDER" "$chapter" || break # break here should result in the return value of rip being used as the return value here
    done
}

function rip ()
# rip /path/to/VIDEO_TS/.. 1:English,2:Commentary title7 chapters1:2-4
{
##TODO: Subtitles. Goal: Star Wars prequels show subtitles during appropriate scenes. Use --subtitle-forced and/or --native-language.


#Process arguments
    local DVD="${1:-/dev/null}"
        # The path to the VIDEO_TS folder or its parent
    local AUDIO_LIST="${2:-}"
        # Which audio tracks to encode. If unspecified, may be inherited.
    local TITLE="${3:-}"
        # Which title to rip. If unspecified, then the longest title is used.
    local CHAPLIST="${4:-}"
        # NOT HANDBRAKE's FORMAT. TODO:FIXME:document
    
    function ripUsage ()
    # nested function FTW
    {
        echo "rip /path/to/DVD 1:English,2:Commentary 7 ep3:2-4" 1>&2
    }

    if ! [ -d "$DVD/VIDEO_TS" ]
    then
        echo "Please specify the path to the DVD (parent of VIDEO_TS) as the first argument." 1>&2
        ripUsage
        return -1
    fi
    
    if test -z "${AUDIO_LIST:-}" && test -z "${AUDIO:-}"
    then
        echo "Please specify the audio track list as the second argument." 1>&2
        ripUsage
        return -2
    fi
    
    #TODO:FIXME: More sanity checks

#Derive settings from arguments, where needed
    local DVDNAME="$(basename "$DVD" .dvdmedia)"
    local CHAPTITL="${CHAPLIST%:*}"
        # What "title" to call this chapter-set
    local CHAPTERS="${CHAPLIST#*:}"
        # What chapters to rip
        # TODO: FIXME: Tested, but unverified
    if [ "${FEATURE:--1}" -eq "${TITLE:-0}" ]
    then
        local DVDNAMEWITHTITLEBUTNOTCHAPTER="$DVDNAME"
        local TRACK=
        #TODO:FIXME:HACK for --longest specified as --title X
    else
        local DVDNAMEWITHTITLEBUTNOTCHAPTER="${DVDNAME}${TITLE:+-}${TITLE}"
        local TRACK="${TITLE:-}"
    fi
    local DVDNAMEWITHTITLE="${DVDNAMEWITHTITLEBUTNOTCHAPTER}${CHAPTITL:+-}${CHAPTITL}"
        # What's the name-track-chapterset of this disc?
    local TRACK="${CHAPTITL:-$TRACK}"
        # TODO:FIXME: Might cause a problem when CHAPTITL isn't numeric
    local AUDIO="${AUDIO:-1,2,3,4,5,6,7,8}"
        # Which audio tracks to encode, see HandBrakeCLI(1), defaulting to all.
        # This will always fail, unless the DVD has all 8 audio tracks, since HandBrake crashes when asked to encode a non-existent track.
        # Inherit a pre-specified $AUDIO, if available.
    local audio_track
    local TMPIFS="$IFS"; IFS=","
    for audio_track in $AUDIO_LIST
    do
        local AUDIO_TITLES="${AUDIO_TITLES:-}${AUDIO_TITLES:+,}${audio_track#*:}"
            # What "title" to call this audio track
        local AUDIO_TRACKS="${AUDIO_TRACKS:-}${AUDIO_TRACKS:+,}${audio_track%:*}"
            # What audio tracks to encode
            # TODO: FIXME: Untested
        local AUDIO="$AUDIO_TRACKS"
    done
    IFS="$TMPIFS"
    unset audio_track TMPIFS
    local FILE="${DVDNAMEWITHTITLE}.m4v"
#    local FILE="${HOME}/Movies/HandBrake/${DVDNAMEWITHTITLE}.m4v"
        # Where to save the output. Store it in ~/Movies/HandBrake with the name of $DVD.
        # Use HandBrake's naming convention, extending it for chapters.

#Derive constants
    local MARKERS="${DVD}/chapters${TITLE:+-}${TITLE:-}.txt"
        # /path/to/DVD/chapters/list/in/CSV
    local AUDIO_ENC="$(IFS=,; for i in $AUDIO; do echo -n ca_aac,; done)"
        # This is, sadly, necessary to work around a bug in HandBrake which will duplicate the last track specified in $AUDIO to until all eight tracks are filled. Bug filed and rejected. :-/

#Do it
    local RET=0
    test -z "${DEBUG_DISABLE_HANDBRAKE_INVOCATION:-}" && (
        test -e "$FILE" && del "$FILE"; \
        set -x; \
    exec HandBrakeCLI -v"${HANDBRAKE_DEBUG_LEVEL:-1}" \
        --preset "Universal" \
        --input "$DVD" \
        "${TITLE:+--title}" "${TITLE:---longest}" \
        "${CHAPTERS:+--chapters}" "${CHAPTERS:-}" \
        --previews 30 \
        --output "$FILE" \
        --markers"${MARKERS:+=}${MARKERS:-}" \
        --ipod-atom \
        --detelecine \
        --vfr \
        --audio "$AUDIO" \
        --aencoder "$AUDIO_ENC" \
        "${AUDIO_TITLES:+--aname}" "${AUDIO_TITLES:-}" \
        "${SPECIAL_RIP_OPTIONS[@]}" \
    2>> ~/Library/Logs/net.gaelicWizard.rip/"$DVDNAME".log ) || RET="$?"
        # Universal preset to activate sensible defaults.
        # Use the longest title, if none specified.
        # Only encode selected chapters, if specified.
        # Generate 30 previews, b/c I hope it will improve autocropping.
            # The number of previews generated is related to the accuracy of the autocropper, but seemingly only two previews are used.
        # Import chapter titles from CSV file, if available.
        # iPod atom, so that 5.5G iPods will accept the media.
        # Detelecine, always. Unclear why HandBrake doesn't just do this.
            # HandBrake documentation for the framerate setting implies that HandBrake does, in fact, detelecine by default, but it lies.
        # Variable Frame Rate is the default, but didn't used to be.
            # This option disappeared _completely_ during 0.9.3
        # Enable selected audio tracks from the DVD.
        # Encode them all to AAC, accepting default Dolby Pro Logic 2 encoding.
            # AAC is the default, so this line might be entirely unneeded.
            # However, the Universal preset duplicates track 1 to track 2 as pass-thru "AC-3", so it might be needed to _return_ to defaults. TODO: Untested, actually.
        # Name the selected audio tracks, e.g. "Director's Commentary".
        # Add any special out-of-band flags to HandBrake, such as "--crop 0:0:0:0" or "--grayscale".

    if [ "${RET:-0}" -ne 0 ]
    then
        return "$RET"
    fi

    if [ -e "$FILE" ]
    then
        #Tweet about it
        if [ -z "${DO_NOT_TWEET_RIPS:-}" ] && [ "${FEATURE:--1}" -eq "${TITLE:-0}" ]
        then
            updateStatus.sh "encoded ${NAME[$TITLE]:-}." &
        fi
    
    growlnotify \
            --name "rip()" \
            --title "Encode Complete" \
            --message "${NAME[$TITLE]:-$DVDNAME} encoded to $(basename "${FILE}")." \
            --appIcon /Applications/HandBrake.app \
            --sticky \
            --identifier net.gaelicWizard.rip
    
        if test "${TITLE:--1}" -eq "${FEATURE:-0}"
        then
            TRACK=
            # Don't embed the track number if this is "the" [only] movie on the disc.
        fi
        
        #Tag some basic housekeeping
        tag "${FILE}" --album "$DVDNAME" "${TRACK:+--track}" "$TRACK"
    else
        echo "$FUNCNAME: ${FILE} does not appear to have been created." 1>&2
        return -2
    fi
    
    addRipOptions # If any SPECIAL_RIP_OPTIONS are set, then issue a warning.
}

function tag ()
# Just a tiny wrapper around AtomicParsley(1)
{
    FILE="$1" ; shift;
    
    test -z "${DEBUG_DISABLE_ATOMICPARSLEY_INVOCATION}" && \
    (set -x; exec AtomicParsley "$FILE" -W "$@" )
}

function addRipOptions ()
# Adds "$@" to global array SPECIAL_RIP_OPTIONS.
{
    for option in "$@"
    do
        SPECIAL_RIP_OPTIONS["${#SPECIAL_RIP_OPTIONS[@]}"]="$option"
    done
    
    if [ -n "${SPECIAL_RIP_OPTIONS[*]}" ]
    then
        echo "WARNING: The following options will apply to all rips until SPECIAL_RIP_OPTIONS is unset:" 1>&2
        echo "${SPECIAL_RIP_OPTIONS[@]}"
    fi
}

function initDVDMedia ()
# This function takes one argument: (1) the path to a DVDMedia bundle. It then writes a few plists into that directory with blank and/or generated values.
{
    local dvdmedia
    if [ x"${1:0:1}" != x"/" ]
    # Make sure that $dvdmedia is an absolute path, in order to work around weird defaults(1) behaviour.
    then
        dvdmedia="$(pwd)/$1"
        # Don't trust $PWD to be set, even though it should _always_ be.
    else
        dvdmedia="$1"
    fi

    local atomicMetadataAlbum="$dvdmedia/atomicMetadataAlbum" \
          atomicMetadataDisc="$dvdmedia/atomicMetadataDisc" \
          atomicMetadataTrack="$dvdmedia/atomicMetadataTrack-" \
          tag atomicPlist
          #atomicMetadataTrack has a hyphen in it since it is expected to be duplicated a number of times.

    for tag in "${theListOfAllTheTrackTags[@]}" "${theListOfAllTheTrackiTunMOVITags[@]}" "${theListOfAdditionalTrackMetadata[@]}"
    do
        defaults write "${atomicMetadataTrack}" "$tag" "_TAG_${tag}_PLACEHOLDER_"
    done
    
    for tag in "${theListOfAllTheDiscTags[@]}" "${theListOfAdditionalDiscMetadata[@]}"
    do
        defaults write "${atomicMetadataDisc}" "$tag" "_TAG_${tag}_PLACEHOLDER_"
    done
    
    defaults write "$atomicMetadataDisc" UDFVolumeName "$(basename "$dvdmedia" .dvdmedia)"
    
    for tag in "${theListOfAllTheAlbumTags[@]}" "${theListOfAdditionalAlbumMetadata[@]}"
    do
        defaults write "${atomicMetadataAlbum}" "$tag" "_TAG_${tag}_PLACEHOLDER_"
    done





    for atomicPlist in "${atomicMetadataTrack}.plist" "${atomicMetadataDisc}.plist" "${atomicMetadataAlbum}.plist"
    do
        plutil -convert xml1 "${atomicPlist}"
        perl -pi -e 's;</key>
	<;</key><;g' "${atomicPlist}"
            #TODO:FIXME: This line of perl is meant to bring the key/value pairs together onto one line, however it doesn't work. I might not be escaping something properly, or perl might be limited to working on one line at a time. I don't know. Oh well. Leave it in. Fix it later. 
    done
    
    SetFile -a T "${atomicMetadataTrack}.plist"
        # When double-clicked in Finder, it will be duplicated and the duplicate opened instead of the original.
}

function autotag ()
# This function takes one argument: (1) the path to a DVDMedia bundle (which has been initDVDMedia()'d). A plist inside the bundle is read for a list of tracks (which would have been already encoded). autoTagTrack() is then invoked for each track using file names generated from the DVDMedia bundle file name.
# Uses autoTagTrack()
{
    local dvdmedia
    if [ x"${1:0:1}" != x"/" ]
    # Make sure that $dvdmedia is an absolute path, in order to work around weird defaults(1) behaviour.
    then
        dvdmedia="$(pwd)/$1"
        # Don't trust $PWD to be set, even though it should _always_ be.
    else
        dvdmedia="$1"
    fi

    local atomicMetadataDisc="$dvdmedia/atomicMetadataDisc"
    local trackList="$(defaults read "$atomicMetadataDisc" trackList 2>/dev/null)" \
          DVDNAME="$(basename "$dvdmedia" .dvdmedia)"

    local aTrack
    for aTrack in $trackList
    do
        autoTagTrack "$dvdmedia" "$aTrack" "$DVDNAME-$aTrack.m4v" || return
    done
    
    
}

function autoTagTrack ()
# This function takes three arguments: (1) the path to a DVDMedia bundle (which has been initDVDMedia()'d), (2) the relevant track number, and (3) the file to tag. The bundle is expected to contain a numbered plist with metadata matching some of the tags below, which will then be passed to tag() to operate on the specified file.
# Uses mkiTunMOVI()
# Uses tag()
{
    local dvdmedia whichTrack m4v \
          tag tagList tempTag iTunMOVIXML

    if [ x"${1:0:1}" != x"/" ]
    # Make sure that $dvdmedia is an absolute path, in order to work around weird defaults(1) behaviour.
    then
        dvdmedia="$(pwd)/$1"
        # Don't trust $PWD to be set, even though it should _always_ be.
    else
        dvdmedia="$1"
    fi

    whichTrack="$2"
    m4v="$3"

    local atomicMetadataAlbum="${dvdmedia}/atomicMetadataAlbum" \
          atomicMetadataDisc="${dvdmedia}/atomicMetadataDisc" \
          atomicMetadataTrack="${dvdmedia}/atomicMetadataTrack-$whichTrack"

    if [ -e "$dvdmedia/JACKET_P.jpg" ] && [ x"$(defaults read "$atomicMetadataTrack" artwork 2>/dev/null || defaults read "$atomicMetadataDisc" artwork 2>/dev/null || defaults read "$atomicMetadataAlbum" artwork 2>/dev/null)" == x"" ] && [ x"$(defaults read "$atomicMetadataTrack" feature 2>/dev/null)" == x"1" ]
    # Cheap hack to ensure that only the feature gets autotag'd with artwork.
    then
        tagList=( "${tagList[@]}" --artwork "${dvdmedia}/JACKET_P.jpg" )
    fi

    for tag in "${theListOfAllTheTrackTags[@]}" "${theListOfAllTheDiscTags[@]}" "${theListOfAllTheAlbumTags[@]}" 
    do
        tempTag="$(defaults read "$atomicMetadataTrack" "$tag" 2>/dev/null || defaults read "$atomicMetadataDisc" "$tag" 2>/dev/null || defaults read "$atomicMetadataAlbum" "$tag" 2>/dev/null )"
        
        if [ x"$tempTag" != x"" ]
        then
            tagList=( "${tagList[@]}" --"$tag" "$tempTag" )
        fi
    done
    
    iTunMOVIXML="$(mkiTunMOVI "$atomicMetadataAlbum" "$atomicMetadataDisc" "$atomicMetadataTrack")"

    tag "$m4v" "${tagList[@]}" \
             "${iTunMOVIXML:+--rDNSatom}" "${iTunMOVIXML:-}" "${iTunMOVIXML:+name=iTunMOVI}" "${iTunMOVIXML:+domain=com.apple.iTunes}"

}

function mkiTunMOVI ()
# Reads relevant information from the plists $1, $2, and $3 and returns a string plist suitable for embedding into an MP4 file with iTunes metadata.
# Uses parseSemicolonDelimitedArray()
{
    local plist="$(mktemp "${TMPDIR:=/tmp}/net.gaelicWizard.rip.iTunMOVI.$$.XXXXX")" || return -3
    local theType studio eachEntry theParsedArray=( )
    local atomicMetadataAlbum="$1" \
          atomicMetadataDisc="$2" \
          atomicMetadataTrack="$3"

    for theType in "${theListOfAllTheTrackiTunMOVITags[@]}"
    do
        parseSemicolonDelimitedArray "$(defaults read "$atomicMetadataTrack" "$theType" 2>/dev/null || defaults read "$atomicMetadataDisc" "$theType" 2>/dev/null || defaults read "$atomicMetadataAlbum" "$theType" 2>/dev/null)" || return -2

        for eachEntry in "${theParsedArray[@]}"
        do
            defaults write "$plist" "$theType" -array-add '{ name = "'"${eachEntry}"'"; }' || return -1
        done
    done

    if studio="$(defaults read "$atomicMetadataTrack" studio 2>/dev/null || defaults read "$atomicMetadataDisc" studio 2>/dev/null || defaults read "$atomicMetadataAlbum" studio 2>/dev/null)"
    then
        defaults write "$plist" studio "$studio"
        # This should overwrite any array written just above.
    fi

    if test -e "${plist}.plist"
    # If we generated a plist, post-process it a bit.
    then
        plutil -convert xml1 -- "${plist}.plist" || return -2

        cat "${plist}.plist"
        command rm -f "${plist}.plist"
    fi
}

function parseSemicolonDelimitedArray ()
# Parses $1 for a semicolon delimited array, and populates the global theParsedArray with the result.
{
    local theUnparsedArray="$1"
    theParsedArray=( ) # Blank the global array.
    local eachEntry i=1
    
    while eachEntry="$(echo "${theUnparsedArray}" | awk -F ';' '{print $'"$i"'}')"
    do
        if [ "${eachEntry}" == "" ]
        then
            break
        fi
    
        if [ "${eachEntry:0:1}" == " " ]
        then
            eachEntry="${eachEntry:1:${#eachEntry}}"
        fi
        
        theParsedArray=( "${theParsedArray[@]}" "${eachEntry}" )
        i=$(( $i + 1 ))
    done
}


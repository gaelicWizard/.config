#!/bin/bash -c 'this file is not executable. source it.'

import trash || return -1
    # Import my trash package for
        # del

export AP_PADDING="DEFAULT_PAD=4096:MIN_PAD=0:MAX_PAD=8192"
export PIC_OPTIONS="removeTempPix:AddBothPix=true"
    # Set up a bunch of defaults for AtomicParsley(1) so that finishing up
    #  the tagging process is later is less painful.

##
# tagging globals
theListOfAllTheTrackTags=( stik contentRating TVEpisode TVEpisodeNum )
theMapOfAllTheTrackTags=( title "description:plotoutline" "year:releasedates[0]" "artist:director[0]" "genre:genres[0]" "comment:keywords[*]" )
    # theListOfAllTheTrackTags[] is for per-track tags which have their own atoms and are directly settable via AtomicParsley(1). The names directly correspond to AtomicParsley(1)'s long arguments.
    # theMapOfAllTheTrackTags[] indicates which key should be read in order to get the appropriate information. Arrays are subscripted.
theListOfAllTheTrackiTunMOVITags=(  )
theMapOfAllTheTrackiTunMOVITags=( "studio:productioncompanies[0]" )
    # theListOfAllTheTrackiTunMOVITags[] is for per-track tags which appear only within the iTunes-style XML data embedded inside the reverse-DNS'd iTunMOVI atom. The names correspond to what iTunes uses, with additional names derived based on those already used.
    # When lowercased and stripped of spaces, the relevant tags should already appear in the plist. 'studio' is special-cased.
theListOfAdditionalTrackMetadata=( imdbID audioList angleList chapterList subtitleList feature usesShow videoTitleSet optimiseCompressionFor )
theMapOfAdditionalTrackMetadata=( "ratingAdvisory:mpaa" )
    # theListOfAdditionalTrackMetadata[] is for additional per-track metadata which are not embedded into the completed container. These are generally for controlling the generation of the encoded video and container or the generation of other metadata.
    # Only 'ratingAdvisory' is used as metadata… it should be moved elsewhere...
theListOfSpecialTrackFlagsForHandBrake=( crop grayscale subtitle-default )
    # theListOfSpecialTrackFlagsForHandBrake[] is for per-track specification of special arguments for HandBrakeCLI(1). These are used as-is, not for generating anything.
theListOfAllTheDiscTags=( disk )
    # theListOfAllTheDiscTags[] is for per-disc (i.e., all tracks on one disc) tags, analogous to theListOfAllTheTrackTags[].
theListOfAdditionalDiscMetadata=( maxtrack trackList UDFVolumeName diskid )
    # theListOfAdditionalDiscMetadata[] is for per-disc metadata, analogous to theListOfAdditionalTrackMetadata[].
theListOfAllTheAlbumTags=( TVShowName TVSeasonNum albumArtist album year artwork )
    # theListOfAllTheAlbumTags[] is for per-album (i.e., all the tracks on all the discs in one album) tags, analogous to theListOfAllTheTrackTags[].
theListOfAdditionalAlbumMetadata=( UPC ISBN ASIN label maxdisk )
    # theListOfAdditionalAlbumMetadata[] is for per-album metadata, analogous to theListOfAdditionalTrackMetadata[].
theListOfAllTheShowTags=( TVNetwork )
    # theListOfAllTheShowTags[] is for per-show (i.e., all the episodes in any track where usesShow is true), analogous to theListOfAllTheTrackTags[].
# end tagging globals
##

function ripDebug ()
{
    export DEBUG_DISABLE_HANDBRAKE_INVOCATION=DEBUG_DISABLE_HANDBRAKE_INVOCATION
    export DEBUG_DISABLE_ATOMICPARSLEY_INVOCATION=DEBUG_DISABLE_ATOMICPARSLEY_INVOCATION
    export DO_NOT_TWEET_RIPS=DO_NOT_TWEET_RIPS
    export DEBUG_DISABLE_TAR_INVOCATION=DEBUG_DISABLE_TAR_INVOCATION
    export HANDBRAKE_DEBUG_LEVEL=1
    
    echo "$DEBUG_DISABLE_HANDBRAKE_INVOCATION; $DEBUG_DISABLE_ATOMICPARSLEY_INVOCATION; $DO_NOT_TWEET_RIPS; $DEBUG_DISABLE_TAR_INVOCATION; $HANDBRAKE_DEBUG_LEVEL" 1>&2
}

function ripAlbum ()
# Loops ripDisc for each "$@"
{
    local dvdmedia

    for dvdmedia in "$@"
    do
        DEBUG_DISABLE_TAR_INVOCATION=DEBUG_DISABLE_TAR_INVOCATION \
        ripDisc "$dvdmedia" || return
    done

    #ripGrowl "${ALBUM}."
}

function sanitiseFilePath ()
# This function should take a string which may not be a valid filesystem path and should produce a valid filesystem path.
#TODO:FIXME: Implement
#TODO:FIXME: Move to general package. Shouldn't be in rip package.
{
    return -1
}

function ripDisc ()
# Invokes rip() on $1 specifying which titles to rip from atomicMetadata, autotagTrack() on each track, then tar(1)s and moves dvdmedia to trash.
# Uses rip()
# Uses ripGrowl()
# Uses autotagTrack()
# Uses del #trash
# Uses defaultsReadAtomicMetadata()
# Uses defaultsReadAtomicMetadatas()
{
    local dvdmedia="$1" \
          track

    local ALBUM="$(defaultsReadAtomicMetadata "$dvdmedia" Album album)" \
          DISK="$(defaultsReadAtomicMetadata "$dvdmedia" Disc disk)" \
          VOLUME="$(defaultsReadAtomicMetadata "$dvdmedia" Disc UDFVolumeName)" \
          MAXDISK="$(defaultsReadAtomicMetadata "$dvdmedia" Album maxdisk)" \
          SHOW="$(defaultsReadAtomicMetadata "$dvdmedia" Album TVShowName)" \
          filepath FILE trackName feature

    ripValidate "$dvdmedia" || return

    if [ "${MAXDISK:-0}" -eq 1 ]
    # No need for per-disc subfolders if there's only one disc.
    then
        filepath="./${SHOW}"
    else
        filepath="./${SHOW}/${ALBUM}: Disc ${DISK}"
    fi
    mkdir -p "./${filepath}" 
        # Since $ALBUM is unsanitised, prefix it with "./" in a poor attempt to reduce errors, or at least reduce unexpected side-effects.
    local ICON="$(echo -ne Icon'\r')"
        # Trick used to circumvent RCS(1)'s mangling of carriage-returns.
    ln -f "${dvdmedia}/$ICON" "./${filepath}/" && SetFile -a C "./${filepath}" && SetFile -a V "./${filepath}/$ICON"
        # Assign an icon to the output folder. 
        # -f to avoid reporting errors that a file exists.

    for track in $(defaultsReadAtomicMetadata "$dvdmedia" Disc trackList)
    do
        feature="$(defaultsReadAtomicMetadatas "$dvdmedia" "$track" feature)"
        if [ "${feature:-0}" -eq 1 ]
        # If $track is "the" main feature. (There may be more than one.)
        then
            trackName="$(defaultsReadAtomicMetadatas "$dvdmedia" "$track" title)"
            FILE="${filepath}/${DISK:-}${DISK:+-}${track} ${trackName}.m4v" # Imitate iTunes file naming.
        else # If $track is not the main feature.
            mkdir -p "./${filepath}/extras" # Create the 'extras' folder, but don't error if it already exists. 
                #TODO:FIXME: This invokes mkdir(1) many times unnecessarily, since a given disk is likely to have many non-feature tracks.
            FILE="${filepath}/extras/${DISK:-}${DISK:+-}${VOLUME}-${track}.m4v" # Variation of HandBrake file naming.
        fi

#        ${HANDBRAKE_DEBUG_LEVEL:+time} \
        rip "$dvdmedia" "$track" "$FILE" \
            && \
        autotagTrack "$dvdmedia" "$track" "$FILE" || return # short-circuit if something fails
    done

    if [ -z "${DEBUG_DISABLE_TAR_INVOCATION:-}" ]
    then
        #TODO:FIXME: Move this to ripAlbum(). Make sure to integrate tarDVDsTogether.sh.
        echo "Tarring…"
        tar c${HANDBRAKE_DEBUG_LEVEL:+v}f "./${filepath}/$(basename "$dvdmedia" .dvdmedia).tar" -C "$(dirname "$dvdmedia")" "$(basename "$dvdmedia")" || return
        del "$dvdmedia" || return
    fi

    ripGrowl "${ALBUM}: Disc ${DISK}" "$VOLUME"
        # Announce completion!
}

function defaultsReadAtomicMetadatas ()
# Uses defaultsReadAtomicMetadata() to repeatedly read various atomicMetadataPlists in dvdmedia $1, track $2, until a value is found for key $3.
{
    local dvdmedia="$1"; shift
    local track="$1"; shift
    
    # The order of calls is important here. 
    # Track should override Show, which should override Disc, which should override Album. 
    # Without overrides, they should fall-through in that order.

    defaultsReadAtomicMetadata "$dvdmedia" Track "$track" "$@" && return # return on success
        # since $3 is only read by defaultsReadAtomicMetadata() when $2 is Track, we have to special-case it.

    if [ x"$(defaultsReadAtomicMetadata "$dvdmedia" Track "$track" usesShow)" == x"1" ]
    # Show is special-cased because bonus material in an album might not share the same show metadata as the actual features.
    then
        defaultsReadAtomicMetadata "$dvdmedia" Show "$@" && return # return on success
    fi

    local metadataType
    for metadataType in Disc Album
    do
        defaultsReadAtomicMetadata "$dvdmedia" "$metadataType" "$@" && return # return on success
    done
}

function defaultsReadAtomicMetadata ()
# Generates a full path (using $1) (minus .plist extension) to the given type of metadata ($2 and maybe $3), and uses defaults(1) to read $@ from it.
# There is code duplication with ripInit().
{
    local dvdmedia="$(realpath "$1")" || return -1
        # This requires a working realpath.
    shift # drop $dvdmedia from "$@"
    local whichAtomicMetadata="$1"; shift
    if [ x"$whichAtomicMetadata" == x"Track" ]
    then
        local whichAtomicMetadataTrack="${1:-}"; shift
    fi

    local atomicMetadataPlist="$dvdmedia/atomicMetadata${whichAtomicMetadata}${whichAtomicMetadataTrack:+-}${whichAtomicMetadataTrack:-}"

    defaults read "$atomicMetadataPlist" "$@" 2>/dev/null
        # Ignore "does not exist" messages.
}

function ripSanity () 
#TODO:FIXME: Merge with ripValidate?
# Check that rip() has sufficient information to operate.
# Uses defaultsReadAtomicMetadatas()
# Uses ripUsage()
{
    if ! test -d "${1}/VIDEO_TS"
    then
        echo "rip(): The first argument must be the full path to a DVDMedia bundle." 1>&2
        echo "       See ripInit()." 1>&2
        ripUsage
        return -1
    fi

    if ! defaultsReadAtomicMetadatas "$1" "$2" audioList >/dev/null
    # Assume that if no audioList can be found for track $2, then that track is not valid (or the atomicMetadata is incomplete).
    then
        echo "rip(): The list of audio tracks must be specified in atomicMetadata." 1>&2
        ripUsage
        return -2
    fi

    #TODO:FIXME: Sanity check for file name.
}

function ripFail () 
{
    RET="${?:-0}" # Preserve the return value.

    if [ x"$1" == x"audioList" ] || [ x"$1" == x"subtitleList" ] || [ x"$1" == x"angleList" ] || [ x"$1" == x"chapterList" ] || [ x"$1" == x"UDFVolumeName" ]
    then
        echo "rip(): Unable to read '$1' from atomicMetadata." 1>&2
        echo "       See initDVDMedia()." 1>&2
    else if [ x"$1" == x"ripParseAudioNames" ] || [ x"$1" == x"ripParseAudioTracks" ]
    then
        echo "rip(): Unable to parse '${2}List' (from atomicMetadata)." 1>&2
    else if [ x"$1" == x"HandBrakeCLI" ]
    then
        echo "rip(): HandBrake has failed to complete successfully." 1>&2
    else if [ x"$1" == x"HandBrakeCLI" ]
    then
        echo "rip(): HandBrake has failed to complete successfully." 1>&2
    fi
    fi
    fi
    fi
        # hacks to fix syntax highlighting in SubEthaEdit circa 3.5.2.
    
    if [ x"$1" == x"angleList" ] || [ x"$2" == x"angle" ]
    # Simple hack to prevent fatal exit when angleList is unspecified.
    #TODO:FIXME: Implement angleList
    #TODO:FIXME: Figure out how to be non-fatal.
    then
        RET=0
    fi

    ripUsage
    return "$RET";
}

function ripParseAudioNames ()
# Code duplication with ripParseAudioTracks().
{
    if [ x"$1" == x"" ] || [ x"$1" == x"_TAG_audioList_PLACEHOLDER_" ]
    then
        return -1
    fi

    local AUDIO_LIST="$1" \
          audio_track \
          track_list \
          firstloop=yes \
          IFS="," # Overriding IFS is ugly, but efficient. Local'd so that it doesn't damage other stuff.
    for audio_track in $AUDIO_LIST
    do
        if [ "$firstloop" == yes ]
        # If this is the first iteration of this loop...
        then
            if [ "$audio_track" == "" ]
            # If the name of this audio track is blank...
            then
                break
                    # Stop the entire loop, preventing parsing of any other audio names and preventing echoing any unnecessary commas.
            fi
            firstloop=no
        fi

        track_list="${track_list:-}${track_list:+,}${audio_track#*:}"
            # What audio tracks to encode
    done

    echo "${track_list:-}"
}

function ripParseAudioTracks () 
# Code duplication with ripParseAudioNames().
{
    if [ x"$1" == x"" ] || [ x"$1" == x"_TAG_audioList_PLACEHOLDER_" ]
    then
        return -1
    fi

    local AUDIO_LIST="$1" \
          audio_track \
          track_list \
          IFS="," # Overriding IFS is ugly, bug efficient. Local'd so that it doesn't damage other stuff.
    for audio_track in $AUDIO_LIST
    do
        track_list="${track_list:-}${track_list:+,}${audio_track%:*}"
            # What audio tracks to encode
            # TODO: FIXME: Untested
    done

    echo "$track_list"
}

function ripUsage () 
{
    echo "Usage: rip /path/to/DVD_VIDEO.dvdmedia 2 /path/to/file.m4v" 1>&2
}

function rip ()
# rip() /path/to/VIDEO_TS/.. 7 /path/to/file.m4v
# Uses defaultsReadAtomicMetadatas()
# Uses ripSanity()
# Uses ripFail()
# Uses ripParseAudioNames() #audio #subtitles #angles
# Uses ripParseAudioTracks()
# Uses addRipOptions()
# Uses SPECIAL_RIP_OPTIONS[]
{
    local dvdmedia="$1" # /path/to/VIDEO_TS's parent
    local whichTrack="$2" # integer, the track number/title number to encode
    local FILE="$3" # the file to save the encoded movie to.
    local SPECIAL_RIP_OPTIONS=( "${SPECIAL_RIP_OPTIONS[@]}" ) atomicRipOption ripOptionArg
         # Localise! #Untested

    ripSanity "$dvdmedia" "$whichTrack" "$chapterList" "$FILE" || return


    local DVDNAME="$(defaultsReadAtomicMetadatas "$dvdmedia" "$whichTrack" UDFVolumeName)" || ripFail "UDFVolumeName" || return
        # Use $DVDNAME as the base name for the log file.

    local chapterList="$(defaultsReadAtomicMetadatas "$dvdmedia" "$whichTrack" chapterList)" || ripFail "chapterList" || return
    local chapterTracks="${chapterList#*:}" # everything before the first colon
    local chapterName="${chapterList%%:*}" # everything after the first colon
        # There should only be one colon. 
        # $chapterName is not the name of the _one_ chapter to be encoded, but the name of the _set_ of chapters to be encoded.

    local audioList="$(defaultsReadAtomicMetadatas "$dvdmedia" "$whichTrack" audioList)" || ripFail "audioList" || return
    local audioNames="$(ripParseAudioNames "$audioList")" || ripFail "ripParseAudioNames" "audio" || return
    local audioTracks="$(ripParseAudioTracks "$audioList")" || ripFail "ripParseAudioTracks" "audio" || return
    local audioEncoders="$(IFS=,; for i in $audioTracks; do echo -n ca_aac,; done)"
        # Ensure that HandBrakeCLI uses the native encoder, which is vastly superior to FAAC.

    local subtitleList="$(defaultsReadAtomicMetadatas "$dvdmedia" "$whichTrack" subtitleList)" || ripFail "subtitleList" || return
    local subtitleNames="$(ripParseAudioNames "$subtitleList")" || ripFail "ripParseAudioNames" "subtitle" || return
        # Unused, due to a lack of support in HandBrake.
    local subtitleTracks="$(ripParseAudioTracks "$subtitleList")" || ripFail "ripParseAudioTracks" "subtitle" || return

    local angleList="$(defaultsReadAtomicMetadatas "$dvdmedia" "$whichTrack" angleList)" #|| ripFail "angleList" || return # angleList is not required
    local angleNames="$(ripParseAudioNames "$angleList")" || ripFail "ripParseAudioNames" "angle" || return
        # Unused.
    local angleTracks="$(ripParseAudioTracks "$angleList")" || ripFail "ripParseAudioTracks" "angle" || return
        # If only one angle is specified, then all is well. However, HandBrake cannot encode multiple angles simultaneously, so this option is presently worthless.
        #TODO:FIXME: Implement.
        # Most likely, the entire rip() will need to be looped in order to accomplish this.

    local videoTitleSet="$(defaultsReadAtomicMetadatas "$dvdmedia" "$whichTrack" videoTitleSet)" #|| ripFail "videoTitleSet" || return
        # This is intended to allow atomicMetadata to override the track/title number in order to allow ripBleach() et al to treat various sets of sub-chapters as distinct titles. 
            # For whatever reason, Anime titles (such as Bleach or Armitage III (OVA)) squeeze separate episodes together into a single title/track, thereby requiring special parsing/processing in order to split them.

    for atomicRipOption in "${theListOfSpecialTrackFlagsForHandBrake[@]}"
    do
        ripOptionArg="$(defaultsReadAtomicMetadatas "$dvdmedia" "$whichTrack" "$atomicRipOption")" && addRipOptions --"$atomicRipOption" "$ripOptionArg"
    done

    local handbrakePreset="$(defaults read net.gaelicWizard.rip preset 2>/dev/null || echo Universal)"
        # Allow override of preset
        # Universal preset is appropriate for all DVD content, since DVDs max at 480p.
            # Uses _roughly_ the __max__ settings iPods 5G/iPods 6G (4:3 ratio) & iPhones/iPods touch (widescreen) support
        # AppleTV preset might be more appropriate for higher-than-480p, since it supports 720p (mostly).
            # AppleTV preset needs adjusting: max resolution should be expanded from 960 to 1280 when fps is 24 or less.
            # Need to do more research on AppleTV tech specs and HandBrake's AppleTV preset.
            # AppleTV does 540p for 30fps, and 720p for 25fps.
        # Some other preset would be appropriate for higher-than-AppleTV-supported, but then why would you be encoding here?
        # See notes/iConstraints, notes/Presets, and notes/x264 settings
    local x264PresetOverride="$(defaults read net.gaelicWizard.HandBrake.x264 "${handbrakePreset:-Universal}" 2>/dev/null)"
        # Override the x264 string from HandBrake's presets. This must be manually maintained.
        # At time of writing, this updates the Universal preset to iPod 6G (no more 5.5G) and enables some much slower encode settings. The output _should_ be fully compatible with iPod 6G and later.
        # At time of writing, this updates the AppleTV preset to use the slower encode settings and reduces the assumed vbv-buffer to something sensible. The output _should_ be fully compatible with the original AppleTV, the iPhone 3GS, and later.
        # At time of writing, this updates the iPad preset to use the slower encode settings. The output _should_ be fully compatible with all A4-based devices.
    local qPresetOverride="$(defaults read net.gaelicWizard.HandBrake.q "${handbrakePreset:-Universal}" 2>/dev/null)"
    
    # Eventually, something should be called here to pass $dvdmedia [Mac BluerayRipper Pro](http://www.macblurayripperpro.com) to [MakeMKV](http://makemkv.com) to [HandBrake](http://handbrake.fr).

#Do it
    local RIPLOG=~/Library/Logs/net.gaelicWizard.rip/"$DVDNAME".log
    ln -sf "$RIPLOG" "$(dirname "$RIPLOG").log" # For easier GeekTool integration
    local RET=0
    test -z "${DEBUG_DISABLE_HANDBRAKE_INVOCATION:-}" && (
        test -e "$FILE" && del "$FILE"; \
        ${HANDBRAKE_DEBUG_LEVEL:+set -x}; \
    exec HandBrakeCLI -v"${HANDBRAKE_DEBUG_LEVEL:-0}" \
        --preset "${handbrakePreset:-Universal}" \
        --input "$dvdmedia" \
        --title "${videoTitleSet:-${whichTrack:-FAIL}}" \
        "${chapterTracks:+--chapters}" "${chapterTracks:-}" \
        "${angleTracks:+--angle}" "${angleTracks:-}" \
        --previews 30 \
        --output "$FILE" \
        --markers="${dvdmedia}/chapters-${whichTrack}.txt" \
        --ipod-atom \
        "${x264PresetOverride:+--x264opts}" "${x264PresetOverride:-}" \
        "${qPresetOverride:+--quality}" "${qPresetOverride:-}" \
        --vfr \
        --audio "$audioTracks" \
        --aencoder "$audioEncoders" \
        "${audioNames:+--aname}" "${audioNames:-}" \
        --strict-anamorphic \
        --decomb \
        --detelecine \
        "${subtitleTracks:+--subtitle}" "${subtitleTracks:-}" \
        "${SPECIAL_RIP_OPTIONS[@]}" \
    2>> "$RIPLOG" ) || ripFail "HandBrakeCLI" || return
        # Universal preset to activate sensible defaults.
        # Only encode selected chapters, if specified.
        # Encode the selected angle, if specified.
        # Generate 30 previews, b/c I hope it will improve autocropping.
            # The number of previews generated is related to the accuracy of the autocropper, but seemingly only two previews are used.
        # Import chapter titles from CSV file, if available.
        # iPod atom, so that iPods 5.5G will accept the media. 
            # Note: iPods 5.5G will likely _not_ accept the h.264, even when the container is marked.
        # Variable Frame Rate is the default, but didn't used to be.
            # This option disappeared _completely_ during 0.9.3 (or .2? somewhere it was invalid...)
        # Enable selected audio tracks.
        # Encode them all to AAC, accepting default Dolby Pro Logic 2 encoding. 
            # This is necessary to ensure that the faster and better CoreAudio encoder is used, instead of the slow and low-quality FAAC.
        # Name the selected audio tracks, e.g. "Director's Commentary".
        # Use Strict anamorphic, which preserves the input more faithfully for _slightly_ slower compression. (Universal preset does not use this due to incorrect assumptions made eons ago by HandBrake developers. The assumption has been corrected, but the preset has not yet been updated.)
        # Decomb. Whenever the input is _visibly_ interlaced, then run the destructive deinterlacer.
            # Simply put: it can't make it worse, but will reduce my cat's excitement at seeing interlaced hands wave in documentaries.
        # Detelecine, always. Unclear why HandBrake doesn't just do this.
            # HandBrake documentation for the framerate setting implies that HandBrake does, in fact, detelecine by default. It lies.
        # Pass-thru the selected subtitles, if specified. (Does _not_ burn-in, as of HandBrake 0.9.4+.)
            # Most subtitles were dropped entirely since HandBrake couldn't embed non-text subtitles until changeset 3325 (between 0.9.4 and 0.9.5).
        # Add any special out-of-band flags to HandBrake, such as "--crop 0:0:0:0" or "--grayscale".
    echo # Blank line, since HandBrakeCLI (at least at 0.9.4) doesn't newline to _stdout_ when exiting.
    unlink "$(dirname "$RIPLOG").log" # Clean up after GeekTool integration
    ${HANDBRAKE_DEBUG_LEVEL:+du -sh "$RIPLOG" 1>&2}
        # Check the size of the log file.
        # Once, a successful rip produced a 15 GB log file due to excessive duplicate non-fatal errors.

    if [ -e "$FILE" ]
    then
        tag "${FILE}" --album "$DVDNAME" --track "$whichTrack"

        ripGrowl "${FILE}" "$DVDNAME"
    fi
}

function ripGrowl ()
{
    local WHAT="$1" \
          BY="$2"

    growlnotify \
        --name "rip()" \
        --title "Rip Complete" \
        --message "Encoded ${WHAT}." \
        --appIcon /Applications/HandBrake.app \
        --sticky \
        --identifier "net.gaelicWizard.rip${BY:+.}${BY:-}"
}

function tag ()
# Just a tiny wrapper around AtomicParsley(1)
{
    FILE="$1" ; shift;

    if [ -z "${DEBUG_DISABLE_ATOMICPARSLEY_INVOCATION}" ]
    then
        ${HANDBRAKE_DEBUG_LEVEL:+set -x}; exec AtomicParsley "$FILE" -W "$@"
    else
        echo "$FUNCNAME $@" 1>&2
    fi
}

function addRipOptions ()
# Adds "$@" to global array SPECIAL_RIP_OPTIONS.
{
    for option in "$@"
    do
        SPECIAL_RIP_OPTIONS["${#SPECIAL_RIP_OPTIONS[@]}"]="$option"
    done
    
    if [ -n "${SPECIAL_RIP_OPTIONS[*]}" ]
    then
        echo "WARNING: The following options will apply to all rips until SPECIAL_RIP_OPTIONS is unset:" 1>&2
        echo "${SPECIAL_RIP_OPTIONS[@]}"
    else
        echo "SPECIAL_RIP_OPTIONS is clear." 1>&2
    fi
}

function ripValidate ()
# This function takes one argument: (1) the path to a DVDMedia bundle. It reads its contents in order to determine if the initial placeholders from ripInit() have been replaced with meaningful content.
# Uses defaultsReadAtomicMetadata().
{
    local dvdmedia="$1" \
          tag whichTrack

    for whichTrack in $(defaultsReadAtomicMetadata "$dvdmedia" Disc trackList)
    do
        #TODO:FIXME: Add explicit check for _TAG_trackList_PLACEHOLDER_.
        for tag in "${theListOfAllTheTrackTags[@]}" "${theListOfAllTheTrackiTunMOVITags[@]}" "${theListOfAdditionalTrackMetadata[@]}" "${theListOfAllTheDiscTags[@]}" "${theListOfAdditionalDiscMetadata[@]}" "${theListOfAllTheAlbumTags[@]}" "${theListOfAdditionalAlbumMetadata[@]}"
        do
            if [ x"$(defaultsReadAtomicMetadatas "$dvdmedia" "$whichTrack" "$tag")" == x"_TAG_${tag}_PLACEHOLDER_" ]
            then
                echo "ripValidate(): Tag placeholders found in ${dvdmedia}." 1>&2
                return 1
            fi
        done
    done
}

function ripInit ()
# This function takes one argument: (1) the path to a DVDMedia bundle. It then writes a few plists into that directory with blank and/or generated values.
# There is code duplication with defaultsReadAtomicMetadata()
# Uses defaultsReadAtomicMetadata()
#TODO: Merge in presortTVShows.sh here. Implemented, untested.
{
    local dvdmedia="$(realpath "$1")" || return -1
        # defaults(1) requires an absolute path.

    local atomicMetadataAlbum="$dvdmedia/atomicMetadataAlbum" \
          atomicMetadataDisc="$dvdmedia/atomicMetadataDisc" \
          atomicMetadataTrack="$dvdmedia/atomicMetadataTrack" \
          atomicMetadataShow="$dvdmedia/atomicMetadataShow" \
          VOLUME="$(defaultsReadAtomicMetadata "$dvdmedia" Disc UDFVolumeName)" \
          DVDNAME="$(basename "$(basename "$dvdmedia" .ripit)" .dvdmedia)" \
          tag trackList eachTrack atomicMetadataTracks
          #atomicMetadataTrack has a hyphen in it since it is expected to be duplicated per track, each with a name such as atomicMetadataTrack-2.

#    local atomicPresetAlbum="$(ripMapVolumeToShow Album "${VOLUME:-$DVDNAME}" )" \
#          atomicPresetDisc="$(ripMapVolumeToShow Disc "${VOLUME:-$DVDNAME}" )" \
#          atomicPresetShow="$(ripMapVolumeToShow Show "${VOLUME:-$DVDNAME}" )" \
#          presetTag
#          # There may be differing amounts of information available for Album, Show, or Disc, so check each separately. 



    HandBrakeCLI -v0 -i "$dvdmedia" -t 0 --scan 2>&1 | LANG=C uniq > "$dvdmedia/titleScan.txt"
        # Ask HandBrake to scan all available titles on the disk.
        # This gathers useful information like length, available audio/subtitle tracks, angles, &c.
        # --scan was introduced in svn changeset 3207 (between 0.9.4 and 0.9.5).

    trackList=( $(awk -F '[ :]' '/^\+ title [0-9]*:/ {print $3}' "$dvdmedia/titleScan.txt") )
        # This extracts the list of titles/tracks that HandBrake has decided are worthy of encoding.



    defaults write "$atomicMetadataShow" usesShow -bool false
        # Just write _anything_ into atomicMetadataShow so that the file exists.

    for eachTrack in "${trackList[@]}"
    do
        for tag in  "${theListOfAllTheTrackTags[@]}" \
                    "${theListOfAllTheTrackiTunMOVITags[@]}" \
                    "${theListOfAdditionalTrackMetadata[@]}" \
                    "${theListOfSpecialTrackFlagsForHandBrake[@]}"
        do
            #presetTag="$(defaults read "$atomicPresetShow" "$tag" 2>/dev/null)"
        
            #if [ x"$presetTag" != x"" ]
            ## Populate atomicMetadataShow if we have something to populate, otherwise stick the placeholder in atomicMetadataTrack.
            #then
            #    defaults write "${atomicMetadataShow}" "$tag" "${presetTag:-_TAG_${tag:-=}_PLACEHOLDER_}"
            #else
            #    defaults write "${atomicMetadataTrack}" "$tag" "_TAG_${tag}_PLACEHOLDER_"
            #fi
        
            defaults write "${atomicMetadataTrack}-${eachTrack}" "$tag" "_TAG_${tag}_PLACEHOLDER_"
        done

        atomicMetadataTracks=( "${atomicMetadataTracks[@]}" "${atomicMetadataTrack}-${eachTrack}" )
    done

    for tag in  "${theListOfAllTheDiscTags[@]}" \
                "${theListOfAdditionalDiscMetadata[@]}"
    do
        #presetTag="$(defaults read "$atomicPresetDisc" "$tag" 2>/dev/null)"
        defaults write "${atomicMetadataDisc}" "$tag" "${presetTag:-_TAG_${tag}_PLACEHOLDER_}"
    done

    defaults write "$atomicMetadataDisc" UDFVolumeName "${VOLUME:-$DVDNAME}" 
        # If UDFVolumeName was already set, then re-use it. Otherwise, assume the folder name.
        #TODO:FIXME: Perhaps this entire function should respect/reuse existing values?

    for tag in  "${theListOfAllTheAlbumTags[@]}" \
                "${theListOfAdditionalAlbumMetadata[@]}"
    do
        #presetTag="$(defaults read "$atomicPresetAlbum" "$tag" 2>/dev/null)"
        defaults write "${atomicMetadataAlbum}" "$tag" "${presetTag:-_TAG_${tag}_PLACEHOLDER_}"
    done

    defaults write "$atomicMetadataDisc" trackList  "${trackList[*]}" 
        # We need one "word" with all the array elements space-delimited, so use "*" instead of "@".

    local atomicPlist
    for atomicPlist in "${atomicMetadataDisc}" "${atomicMetadataAlbum}" "${atomicMetadataShow}" "${atomicMetadataTracks[@]}"
    #TODO:FIXME: atomicMetadataShow.plist might not exist, and might therefore produce [harmless] errors.
    do
        atomicPlist="${atomicPlist}.plist"
        [ -e "${atomicPlist}" ] || continue
        
        plutil -convert xml1 "${atomicPlist}"
            # Convert to textual XML instead of "binary plist"
        SetFile -a E "${atomicPlist}"
            # Hide the file extension in Finder.app
    done

    # The rest of this function works in conjunction with a launchd job (net.gaelicWizard.rip.copy-extras) to ensure that the contents of a DVD are fully copied. (RipIt re-authors a VIDEO_TS folder, but nothing else.)
    local EXTRASTAR="${DVDNAME}-extras.tar"
    local EXTRASTARPATH=~/Movies/HandBrake/"$EXTRASTAR" # TODO:FIXME: come up with a better path for this. 
    if [ -e "$EXTRASTARPATH" ]
    then
        tar -v -f "$EXTRASTARPATH" --strip-components 1 -C "$dvdmedia" -x \
            && \
        rm "$EXTRASTARPATH"
            #del()

        [ -d "$dvdmedia/AUDIO_TS" ] && rmdir "$dvdmedia/AUDIO_TS"
            # Clear out empty and utterly unnecessary superfluous directories.
    fi
}

function ripMapVolumeToShow ()
# The logic from presortTVShows.sh
{
    return -1
    # Idea: store a regular expression or some such that matches a given volume name, instead of trying to match manually.
    #       perhaps using bash(1)'s own matching features?
}

function autotagTrack ()
# This function takes three arguments: 
#   (1) the path to a DVDMedia bundle (which has been initDVDMedia()'d), 
#   (2) the relevant track number, and 
#   (3) the file to tag. The bundle is expected to contain a numbered plist with metadata matching some of the tags below, which will then be passed to tag() to operate on the specified file.
# Uses defaultsReadAtomicMetadatas()
# Uses mkiTunMOVI()
# Uses tag()
{
    local dvdmedia="$1" \
          whichTrack="$2" \
          m4v="$3" \
          tag tagList tempTag iTunMOVIXML imdbTag apTag

    if [ -e "$dvdmedia/JACKET_P.jpg" ] \
    && [ x"$(defaultsReadAtomicMetadatas "$dvdmedia" "$whichTrack" artwork)" == x"" ] \
    && [ x"$(defaultsReadAtomicMetadatas "$dvdmedia" "$whichTrack" feature)" == x"1" ]
    # Cheap hack to ensure that only the feature gets autotag'd with artwork.
    #TODO:FIXME: Should switch to a customArtwork/needsArtwork flag.
    then
        tagList=( "${tagList[@]}" --artwork "${dvdmedia}/JACKET_P.jpg" )
    fi

    for tag in "${theListOfAllTheDiscTags[@]}" "${theListOfAllTheAlbumTags[@]}" 
    do
        tempTag="$(defaultsReadAtomicMetadatas "$dvdmedia" "$whichTrack" "$tag")"
        
        if [ x"$tempTag" != x"" ]
        then
            tagList=( "${tagList[@]}" --"$tag" "$tempTag" )
        fi
    done
    
    autotagOnce "${dvdmedia}/atomicMetadataTrack-${whichTrack}" "$m4v" "${tagList[@]}" 
}

function autotagOnce ()
# $1 /path/to/plist
# $2 /path/to/m4v
# $3 ${additionalArgumentsToTag[@]}
{
    local defaultsDomain="$(dirname "$1")/$(basename "$1" .plist)" \
          m4v="$2" \
          tag tagList tempTag imdbTag apTag
          # Use of realpath(1) is to get the path to the file, not to get a different "more real" path than the given path. (i.e., its not intended to resolve symlinks, but it does. 

    shift; shift # Discard $1 and $2.
    local additionalArgumentsToTag=( "$@" )
    
    for tag in "${theMapOfAllTheTrackTags[@]}"
    do
        apTag="${tag%%:*}"
        imdbTag="${tag##*:}"
        tempTag="$(defaults read  "$defaultsDomain" "$imdbTag")"
        
        if [ x"$tempTag" != x"" ]
        then
            tagList=( "${tagList[@]}" --"$apTag" "$tempTag" )
        fi
    done
    
    for tag in "${theListOfAllTheTrackTags[@]}" "${theListOfAllTheDiscTags[@]}" "${theListOfAllTheAlbumTags[@]}" 
    do
        tempTag="$(defaults read  "$defaultsDomain" "$tag" 2>/dev/null )"

        if [ x"$tempTag" != x"" ]
        then
            tagList=( "${tagList[@]}" --"$tag" "$tempTag" )
        fi
    done

    plutil -convert xml1 "${defaultsDomain}.plist"
    iTunMOVIXML="$(< "${defaultsDomain}.plist")"

    tag "$m4v" "${tagList[@]}" \
               "${iTunMOVIXML:+--rDNSatom}" \
                    "${iTunMOVIXML:-}" \
                    "${iTunMOVIXML:+name=iTunMOVI}" \
                    "${iTunMOVIXML:+domain=com.apple.iTunes}" \
               "${additionalArgumentsToTag[@]}"
}

function mkiTunMOVI ()
# Reads relevant information from the plists embedded in $1 and returns a plist (as a string) with iTunes metadata suitable for embedding into an MP4 container.
# Uses parseSemicolonDelimitedArray()
# Uses defaultsReadAtomicMetadatas()
{
    { echo "mkiTunMOVI()"; exit -1; }

    local plist="$(mktemp "${TMPDIR:=/tmp}/net.gaelicWizard.rip.iTunMOVI.$$.XXXXX")" || return -3
    local theType studio eachEntry theParsedArray=( )
    local dvdmedia="$1" track="$2"

    for theType in "${theListOfAllTheTrackiTunMOVITags[@]}"
    do
        parseSemicolonDelimitedArray "$(defaultsReadAtomicMetadatas "$dvdmedia" "$track" "$theType")" || return -2

        for eachEntry in "${theParsedArray[@]}"
        do
            defaults write "$plist" "$theType" -array-add '{ name = "'"${eachEntry}"'"; }' || return -1
        done
    done

    if studio="$(defaultsReadAtomicMetadatas "$dvdmedia" "$track" studio)"
    then
        defaults write "$plist" studio "$studio"
        # This should overwrite any array written just above.
    fi

    if test -e "${plist}.plist"
    # If we generated a plist, post-process it a bit.
    then
        plutil -convert xml1 -- "${plist}.plist" || return -2

        cat "${plist}.plist"
        command rm -f "${plist}.plist"
    fi
}

function parseSemicolonDelimitedArray ()
# Parses $1 for a semicolon delimited array, and populates the global theParsedArray with the result.
{
    local theUnparsedArray="$1"
    theParsedArray=( ) # Blank the global array.
    local eachEntry i=1
    
    while eachEntry="$(echo "${theUnparsedArray}" | awk -F ';' '{print $'"$i"'}')"
    do
        if [ "${eachEntry}" == "" ]
        then
            break
        fi
    
        if [ "${eachEntry:0:1}" == " " ]
        then
            eachEntry="${eachEntry:1:${#eachEntry}}"
        fi
        
        theParsedArray=( "${theParsedArray[@]}" "${eachEntry}" )
        i=$(( $i + 1 ))
    done
}


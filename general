#!/bin/sh -c 'echo This file is meant to be sourced.'

require path || return -1
    # Import my path package

# Path    # No need as of Snow Leopard, when /etc/paths.d finally works
#bashd_add_to_path_back "/usr/X11/bin"
    # Add X 
#bashd_add_to_path_front "/usr/sbin"
#bashd_add_to_path_front "/sbin"
    # Add sbin

#bashd_add_to_path_front "${HOME}/Library/Scripts" # Should have?
bashd_add_to_path_front "${HOME}/Tools"
    # Add my home folder tools
    # Duplicate, but more portable. I've added '~/Tools' to /etc/paths.d/Home, which is understood as expected by shells, but not by tools which lack tilde-expansion.

alias locate='locate.sh'
alias sshfs='/Applications/MacFUSE/sshfs.app/Contents/Resources/sshfs-static'
alias sshfs_orpheus='sshfs eon: ~/.temp/sshfs_mount_point -oreconnect,ping_diskarb,volname=Orpheus'
export FTP_PASSIVE=1

## Generally useful functions :-)
function ls ()
{ command ls -AGFOh "$@" ; } 
    # 'command ls' to prevent loop; -A for .file, -G for color, -F for dir/ link@, 
    # -h for 5k 3m 1g, -O for uchg...
function l ()
{ ls -l "$@"; } 
    # -l to list in long format...
function ll ()
{ CLICOLOR_FORCE='1' l "$@" | less -e -R ; } 
    # pipe into 'less', tell less to honor colors and to exit at end
function cd ()
{ builtin cd "$@" >/dev/null ; } 
    # Make 'cd' NOT print the new dir! by piping stdout to /dev/null
    # Does not effect the printing of errors, only useful if $CDPATH is set

function lleaks ()
{
    leaks "$@" | less
}

alias which='type -p' # 'which' in (t)csh is same(?) as 'type -p' in bash...?

## Tips and Ticks... from http://www.caliban.org/bash/index.shtml
# The $CDPATH variable is so that you can be in /path/to/something and 'cd' 
# to 'somethingElse' and end up in /not/the/same/path/to/somethingElse! 
CDPATH=".:~:/Volumes"
#
shopt -s cdspell checkwinsize nocaseglob
    # Spell check for 'cd', reset WIDTH/ROWS on sigwinch
    #  case-insensitive completion
##

mkdir -p -m u+rwX,go-rwx ~/.temp
    # Make sure that my own temp folder exists.

# Set $UID for easy access
#[ -z "${UID:-}" ] && UID=`id -u`
#export UID

# Set $COLORTERM, all this does is trick *some* apps into 
# using color in the terminal, which should happen anyway.
if [ -z "${COLORTERM:-}" ];then 
	export COLORTERM="${TERM}" 
	   # I don't know what COLORTERM should actually be set to
fi

# Be careful there...
alias cp='cp -i' # Don't overwrite w/o my permission!
alias mv='mv -i' # Ditto...
 
alias swap="vm_stat && ls -l /var/vm/swapfile* | awk '{print \$6 \" \"  \$10}'"
    # How many swap files again?
alias swaploop="while clear; do swap; sleep 10; done"

alias flushcache="dscacheutil -flushcache"


# Usage : seq n m [i]
# echo all integers between n and m using a skip or increment of i
function seq ()
{
    [ "$1" ] || [ "$2" ] || return 1
    
    local x=$1;
    local y=$2;
    local i=${3:-1};
    local seperator="${4:- }"
    while [ $x -le $y ]
    do
        echo -n $x"${seperator}";
        x=$(( $x + $i ));
    done
    echo
}

function randomint ()
{
    dd if=/dev/random count=1 2>/dev/null | od -t u1 | awk 'NR==1 {print $2$4}'
}

function randomword ()
{
    sed "$(randomint)""q;d" /usr/share/dict/words
}

function chext ()
{ 
    local FILE
    if [ "$#" -lt 3 ]
    then
        rtrn 1
    fi
    # TODO: input validation...
    for FILE in *."$1"
    do 
        mv -v "$FILE" "`echo $FILE | sed 's/\(.*\.\)'$1'/\1'$2'/'`" 
    done
}

# Some aliases to fix line-endings. 
alias LF="perl -pi -e 's/\r\n/\n/g;s/\r/\n/g' "
alias CR="perl -pi -e 's/\r\n/\n/g;s/\n/\r/g' "
alias CRLF="perl -pi -e 's/\r\n/\n/g;s/\r/\n/g;s/\n/\r\n/g' "

alias chmac=CR # Make all line endings all mac
alias chunx=LF # Make all line endings all unix
alias chdos=CRLF # Make all line endings all windoze

alias iforgot='sudo strings /var/vm/swapfile? |grep -A 4 -i longname ;echo'
    # This searches my swap files for my password


function isinteractive () 
{ [[ "$-" = *i* ]]; return "$?"; }
    # Check if the current shell was invoked interactively

##
if isinteractive
then
    PS1="[\h:\w] \[\033[1;34m\]\u\[\033[0m\]\`[ \$? -ne 0 ] && echo -n '\[\e[00;31m\]'\`\\$\`echo -n '\[\e[0m\]'\` "
    bind '"\e[A"':history-search-backward
    	# Bind the up arrow to history search, instead of history step...
    bind '"\e[B"':history-search-forward
	   # Ditto for down, type "x" [up] and it will look for the last x??? command
fi
        # My prompt line: 	"[hostname:~/Documents] <span style="font-color:blue;font-weight:bold;">user</span>$ " ('#' instead of '$', if root) ('$' becomes <span style="font-color:red;">$</span> when previous command failed)
##


# The rest are uncategorised and fairly random... :-)
alias ztpm='ps axm -o pid,stat,rss,time,command | head -20' 
    # Ummm....? I don't know what this does, actually...
alias note='cat >> "`date "+%a %b %e %Y"`.txt"'
alias screen_aevt='screen env AEDebugReceives=1 AEDebugSends=1'

#set -o noclobber

function pidof () { ps -Ac | awk '/'"$*"'/ {print $1}'; }

function ass ()
{
    if [ "$1" ] && declare -F isscreen >/dev/null && isscreen
    then
        screen -t "$(basename $1)" 20 tail -F "$@"
    else
        tail -F "$@"
    fi
}

function google ()
{
    open 'http://www.google.com/search?client=safari&q='"$*"
}
